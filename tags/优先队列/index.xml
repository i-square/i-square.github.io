<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>优先队列 on 平方君的后花园</title><link>https://i-square.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link><description>Recent content in 优先队列 on 平方君的后花园</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Thu, 20 Apr 2017 22:27:15 +0000</lastBuildDate><atom:link href="https://i-square.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title>数据结构学习笔记（六）：优先队列（堆）</title><link>https://i-square.github.io/p/Data-structure-study-notes-6-priority-queue-heap/</link><pubDate>Thu, 20 Apr 2017 22:27:15 +0000</pubDate><guid>https://i-square.github.io/p/Data-structure-study-notes-6-priority-queue-heap/</guid><description>&lt;p>本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用&lt;br>
作者评价：这类数据结构属于计算机科学中最雅致的一种&lt;/p>
&lt;h2 id="内容">内容&lt;/h2>
&lt;ul>
&lt;li>优先队列ADT的高效实现&lt;/li>
&lt;li>优先队列的使用&lt;/li>
&lt;li>优先队列的高级实现&lt;/li>
&lt;/ul>
&lt;h2 id="二叉堆-binary-heap">二叉堆 (binary heap)&lt;/h2>
&lt;p>插入删除最坏O(logN)，实际上插入花费常数平均时间，若无删除干扰，该结构将以线性时间建立一个具有N项的优先队列。&lt;br>
与二叉查找树一样，堆具有两个性质，堆的操作必须满足所有性质才能终止。&lt;/p>
&lt;h3 id="结构性质">结构性质&lt;/h3>
&lt;p>堆是一棵&lt;strong>完全二叉树&lt;/strong>（三角形缺右下角），特例是满二叉树（三角形），最底层元素必须从左往右填入，如有空缺则不是完全二叉树&lt;br>
一棵高为h的完全二叉树有[2^h , 2^(h+1) - 1]个节点，这意味着完全二叉树的高是 下取整(logN)，显然它是O(logN)的&lt;br>
因为此规律，所以堆可以用数组表示而不用链表，对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的(2i+1)上，它的父亲在位置 下取整(i/2) 上&lt;/p>
&lt;h3 id="堆序性质">堆序性质&lt;/h3>
&lt;p>在堆中，除根节点以外，每一个节点的值都大于（或等于）它的父节点的值&lt;br>
根据堆序性质，最小值总在根结点，因此可以以O(1)时间做findMin&lt;br>
相应地，通过改变堆序性质，也可以建立一个max堆，以O(1)时间做findMax&lt;/p>
&lt;h3 id="插入上滤策略">插入（上滤策略）&lt;/h3>
&lt;p>为了插入新元素X，在堆的下一个可用位置（为了满足结构性质）创建一个空穴，若X放入空穴仍满足堆序性质，则插入完成，否则交换空穴和其父节点，直到X被放入并满足堆序性质为止&lt;/p>
&lt;h3 id="删除下滤策略">删除（下滤策略）&lt;/h3>
&lt;p>找出最小元很容易，难的是删除它。&lt;br>
当删除一个最小元时，堆中最后一个元素X必须移动到该堆的某个地方。策略是在根节点建立一个空穴，然后将两个儿子中的较小者移入空穴，重复该步骤直到X可以被放入空穴中。代码中则是用X直接替换根结点的值，然后下滤。&lt;/p>
&lt;h3 id="注意">注意&lt;/h3>
&lt;p>在堆的实现中经常出现的错误是，当堆中存在偶数个元素时，将出现一个节点只有一个儿子的情况。因此我们必须以节点不总有两个儿子为前提，这需要额外的测试。&lt;/p>
&lt;h3 id="应用">应用&lt;/h3>
&lt;h4 id="选择问题">选择问题&lt;/h4>
&lt;p>输入N个元素及整数k，找出第k个最大的元素，极端情况是k=上取整(N/2)，此时实际上是找中位数，以下两个算法都能在找中位数的情况下以O(NlogN)时间运行&lt;/p>
&lt;ul>
&lt;li>A 将N个元素读入数组，对数组应用buildHeap，再执行k次deleteMin，最后根节点上的就是第k个最小值，构造一个最大堆就可以找到第k个最大值&lt;/li>
&lt;li>B 用buildHeap将前k个元素构造成一个最大堆，若下一个元素大于堆里的最小值，则删除最小值，插入新元素，最终的最小值就是所求的第k个最大值&lt;/li>
&lt;/ul>
&lt;h2 id="d堆">d堆&lt;/h2>
&lt;p>类似B树，深度变浅，每个节点有d个儿子&lt;/p>
&lt;h2 id="左式堆-leftist-heap">左式堆 (leftist heap)&lt;/h2>
&lt;p>左式堆也是二叉树，但它不是理想平衡的，事实上是趋于非常不平衡&lt;/p>
&lt;p>定义任一节点X的**零路径长(null path length)**npl(X)为从X到一个不具有两个儿子的节点的最短路径长&lt;br>
因此，具有0个或1个儿子的节点npl为0，而npl(NULL)=-1&lt;br>
注意，任一节点的npl比它儿子节点的npl的最小值多1&lt;/p>
&lt;h3 id="左式堆性质">左式堆性质&lt;/h3>
&lt;p>对于堆中的每一个节点X，左儿子的npl至少与右儿子的npl一样大&lt;br>
这个性质导致树向左增加深度，沿左式堆右侧的右路径是堆中最短的路径&lt;br>
定理：在右路径上有r个节点的左式堆必然至少有2^r -1个节点&lt;/p>
&lt;p>对左式堆的基本操作是合并。插入可以看成是合并一个单节点堆，删除即是删掉根结点，然后合并左右子树。&lt;/p>
&lt;h2 id="斜堆-skew-heap">斜堆 (skew heap)&lt;/h2>
&lt;p>斜堆是左式堆的自调节形式，具有堆序，但不存在结构限制。斜堆不需要存储npl，每次合并无条件交换左右儿子。&lt;/p>
&lt;h2 id="二项队列-binomial-queue">二项队列 (binomial queue)&lt;/h2>
&lt;p>以最坏O(logN)支持插入、合并、deleteMin，插入操作平均花费常数时间&lt;/p>
&lt;p>实质是由&lt;strong>二项树&lt;/strong>(binomial tree)构成的&lt;strong>森林&lt;/strong>(forest)。&lt;br>
每一个高度上最多存在一棵二项树。高度为k的二项树Bk是通过将一棵二项树B(k-1)附接到另一棵二项树B(k-1)的根上构成的。高度为k的二项树有2^k个节点，在深度d处的节点数是二项系数C(d,k)&lt;/p>
&lt;p>如果把堆序性质施加到二项树上并允许任意高度上最多一棵二项树，则可以用二项树的集合唯一地表示任意大小的优先队列。如大小为13的优先队列可以用B3,B2,B0表示，可以写成1101，同时也是13的二进制形式。&lt;/p>
&lt;h3 id="操作">操作&lt;/h3>
&lt;p>基本操作仍然是合并，思想是从小到大合并相同高度的二项树&lt;br>
插入是特殊情况下的合并&lt;br>
deleteMin将原二项队列一分为二，再合并&lt;/p>
&lt;p>编程需要注意&lt;strong>进位&lt;/strong>的实现&lt;/p></description></item></channel></rss>