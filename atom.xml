<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>平方君的后花园</title>
  <subtitle>Keep It Simple, Stupid.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://i-square.github.io/"/>
  <updated>2017-04-20T14:27:48.633Z</updated>
  <id>https://i-square.github.io/</id>
  
  <author>
    <name>平方君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构学习笔记（六）：优先队列（堆）</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A0%86%EF%BC%89/"/>
    <id>https://i-square.github.io/post/DS学习笔记-优先队列（堆）/</id>
    <published>2017-04-20T14:27:15.000Z</published>
    <updated>2017-04-20T14:27:48.633Z</updated>
    
    <content type="html"><![CDATA[<p>本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用<br>作者评价：这类数据结构属于计算机科学中最雅致的一种</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>优先队列ADT的高效实现</li>
<li>优先队列的使用</li>
<li>优先队列的高级实现</li>
</ul>
<h2 id="二叉堆-binary-heap"><a href="#二叉堆-binary-heap" class="headerlink" title="二叉堆 (binary heap)"></a>二叉堆 (binary heap)</h2><p>插入删除最坏O(logN)，实际上插入花费常数平均时间，若无删除干扰，该结构将以线性时间建立一个具有N项的优先队列。<br>与二叉查找树一样，堆具有两个性质，堆的操作必须满足所有性质才能终止。</p>
<h3 id="结构性质"><a href="#结构性质" class="headerlink" title="结构性质"></a>结构性质</h3><p>堆是一棵<strong>完全二叉树</strong>（三角形缺右下角），特例是满二叉树（三角形），最底层元素必须从左往右填入，如有空缺则不是完全二叉树<br>一棵高为h的完全二叉树有[2^h , 2^(h+1) - 1]个节点，这意味着完全二叉树的高是 下取整(logN)，显然它是O(logN)的<br>因为此规律，所以堆可以用数组表示而不用链表，对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的(2i+1)上，它的父亲在位置 下取整(i/2) 上</p>
<h3 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h3><p>在堆中，除根节点以外，每一个节点的值都大于（或等于）它的父节点的值<br>根据堆序性质，最小值总在根结点，因此可以以O(1)时间做findMin<br>相应地，通过改变堆序性质，也可以建立一个max堆，以O(1)时间做findMax</p>
<h3 id="插入（上滤策略）"><a href="#插入（上滤策略）" class="headerlink" title="插入（上滤策略）"></a>插入（上滤策略）</h3><p>为了插入新元素X，在堆的下一个可用位置（为了满足结构性质）创建一个空穴，若X放入空穴仍满足堆序性质，则插入完成，否则交换空穴和其父节点，直到X被放入并满足堆序性质为止</p>
<h3 id="删除（下滤策略）"><a href="#删除（下滤策略）" class="headerlink" title="删除（下滤策略）"></a>删除（下滤策略）</h3><p>找出最小元很容易，难的是删除它。<br>当删除一个最小元时，堆中最后一个元素X必须移动到该堆的某个地方。策略是在根节点建立一个空穴，然后将两个儿子中的较小者移入空穴，重复该步骤直到X可以被放入空穴中。代码中则是用X直接替换根结点的值，然后下滤。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在堆的实现中经常出现的错误是，当堆中存在偶数个元素时，将出现一个节点只有一个儿子的情况。因此我们必须以节点不总有两个儿子为前提，这需要额外的测试。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h4><p>输入N个元素及整数k，找出第k个最大的元素，极端情况是k=上取整(N/2)，此时实际上是找中位数，以下两个算法都能在找中位数的情况下以O(NlogN)时间运行</p>
<ul>
<li>A 将N个元素读入数组，对数组应用buildHeap，再执行k次deleteMin，最后根节点上的就是第k个最小值，构造一个最大堆就可以找到第k个最大值</li>
<li>B 用buildHeap将前k个元素构造成一个最大堆，若下一个元素大于堆里的最小值，则删除最小值，插入新元素，最终的最小值就是所求的第k个最大值</li>
</ul>
<h2 id="d堆"><a href="#d堆" class="headerlink" title="d堆"></a>d堆</h2><p>类似B树，深度变浅，每个节点有d个儿子</p>
<h2 id="左式堆-leftist-heap"><a href="#左式堆-leftist-heap" class="headerlink" title="左式堆 (leftist heap)"></a>左式堆 (leftist heap)</h2><p>左式堆也是二叉树，但它不是理想平衡的，事实上是趋于非常不平衡</p>
<p>定义任一节点X的<strong>零路径长(null path length)</strong>npl(X)为从X到一个不具有两个儿子的节点的最短路径长<br>因此，具有0个或1个儿子的节点npl为0，而npl(NULL)=-1<br>注意，任一节点的npl比它儿子节点的npl的最小值多1</p>
<h3 id="左式堆性质"><a href="#左式堆性质" class="headerlink" title="左式堆性质"></a>左式堆性质</h3><p>对于堆中的每一个节点X，左儿子的npl至少与右儿子的npl一样大<br>这个性质导致树向左增加深度，沿左式堆右侧的右路径是堆中最短的路径<br>定理：在右路径上有r个节点的左式堆必然至少有2^r -1个节点</p>
<p>对左式堆的基本操作是合并。插入可以看成是合并一个单节点堆，删除即是删掉根结点，然后合并左右子树。</p>
<h2 id="斜堆-skew-heap"><a href="#斜堆-skew-heap" class="headerlink" title="斜堆 (skew heap)"></a>斜堆 (skew heap)</h2><p>斜堆是左式堆的自调节形式，具有堆序，但不存在结构限制。斜堆不需要存储npl，每次合并无条件交换左右儿子。</p>
<h2 id="二项队列-binomial-queue"><a href="#二项队列-binomial-queue" class="headerlink" title="二项队列 (binomial queue)"></a>二项队列 (binomial queue)</h2><p>以最坏O(logN)支持插入、合并、deleteMin，插入操作平均花费常数时间</p>
<p>实质是由<strong>二项树</strong>(binomial tree)构成的<strong>森林</strong>(forest)。<br>每一个高度上最多存在一棵二项树。高度为k的二项树Bk是通过将一棵二项树B(k-1)附接到另一棵二项树B(k-1)的根上构成的。高度为k的二项树有2^k个节点，在深度d处的节点数是二项系数C(d,k)</p>
<p>如果把堆序性质施加到二项树上并允许任意高度上最多一棵二项树，则可以用二项树的集合唯一地表示任意大小的优先队列。如大小为13的优先队列可以用B3,B2,B0表示，可以写成1101，同时也是13的二进制形式。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>基本操作仍然是合并，思想是从小到大合并相同高度的二项树<br>插入是特殊情况下的合并<br>deleteMin将原二项队列一分为二，再合并</p>
<p>编程需要注意<strong>进位</strong>的实现</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用&lt;br&gt;作者评价：这类数据结构属于计算机科学中最雅致的一种&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C盘根目录下的两个sys文件说明</title>
    <link href="https://i-square.github.io/post/C%E7%9B%98%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AAsys%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
    <id>https://i-square.github.io/post/C盘根目录下的两个sys文件说明/</id>
    <published>2017-04-19T08:24:22.000Z</published>
    <updated>2017-04-19T08:43:58.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实验室里有一台高配工作站，内存有512GB，用一块256GB的SSD安装Win7 x64操作系统以后，硬盘空间只剩下几十MB了，查看C盘下的文件之后，发现有两个隐藏的系统文件占用了200GB+的空间，于是马上查了它们的来头。</p>
<a id="more"></a>
<h2 id="pagefile-sys"><a href="#pagefile-sys" class="headerlink" title="pagefile.sys"></a>pagefile.sys</h2><p><code>pagefile.sys</code>是系统安装过程中创建的虚拟内存页面文件。这个文件的大小是自己系统虚拟内存设置的最小值的大小。假如虚拟内存的设置为800MB－1600MB 那么你在自己的设定驱动盘下面就可看到大小为800MB的<code>pagefile.sys</code>文件。</p>
<h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>通常自己可以在<code>我的电脑</code>右键<code>属性</code>–&gt;<code>高级</code>–&gt;<code>性能</code>–&gt;<code>高级</code>–&gt;<code>虚拟内存</code>中将所有盘的虚拟内存设置为无分页文件，并选择<code>设置</code>后重启系统，就可以删除页面文件<code>pagefile.sys</code>。</p>
<h2 id="hiberfil-sys"><a href="#hiberfil-sys" class="headerlink" title="hiberfil.sys"></a>hiberfil.sys</h2><p>这个文件是系统的休眠功能所占用的硬盘空间的文件（Windows默认休眠功能是处于打开状态的），电脑处于休眠状态时，内存中的所有内容将保存到硬盘，并且电脑会被关闭。电脑在返回打开状态之后，关闭电脑时打开的所有程序和文档将全都还原到桌面。也就是说，当你让电脑进入休眠状态时，Windows在关闭系统前将所有的内存内容写入<code>hiberfil.sys</code>文件，当你重新打开电脑，操作系统使用<code>hiberfil.sys</code>把所有信息放回内存，电脑恢复到关闭前的状态。然而，只要休眠功能开启，Windows就会在硬盘上留下<code>hiberfil.sys</code>文件，即使你从来不休眠。</p>
<h3 id="优化方法-1"><a href="#优化方法-1" class="headerlink" title="优化方法"></a>优化方法</h3><p>以管理员身份运行CMD，然后输入命令<code>powercfg -h off</code>，回车后立即生效，<code>hiberfil.sys</code>文件已经不见了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;实验室里有一台高配工作站，内存有512GB，用一块256GB的SSD安装Win7 x64操作系统以后，硬盘空间只剩下几十MB了，查看C盘下的文件之后，发现有两个隐藏的系统文件占用了200GB+的空间，于是马上查了它们的来头。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Windows" scheme="https://i-square.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（五）：散列</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%A3%E5%88%97/"/>
    <id>https://i-square.github.io/post/DS学习笔记-散列/</id>
    <published>2017-04-07T14:48:51.000Z</published>
    <updated>2017-04-19T08:46:25.022Z</updated>
    
    <content type="html"><![CDATA[<p>散列表（hash table）的实现通常称为散列（hashing），指用于以O(1)时间执行插入、删除和查找的技术，但不支持需要排序信息的树操作，比如findMin、findMax以及在线性时间内按顺序打印整个表都不支持</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>中心数据结构是<strong>散列表</strong></p>
<ul>
<li>实现散列表的几种方法</li>
<li>分析比较几种方法</li>
<li>介绍散列的多种应用</li>
<li>比较散列表与二叉查找树</li>
</ul>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>基本思想：将每个键(Key)映射到从[0, TableSize)这个范围中的某个数，并且将其放到适当的单元中，这个映射就称为<strong>散列函数</strong>。<br>问题：选择一个函数，决定当两个键散列到同一个值的时候（称为<strong>冲突(collision)</strong>应该做什么以及如何确定散列表的大小。<br><em>注：一般使表的大小为素数，有助于避免部分冲突问题</em></p>
<h3 id="装填因子-load-factor"><a href="#装填因子-load-factor" class="headerlink" title="装填因子(load factor)"></a>装填因子(load factor)</h3><p>定义散列表的装填因子 λ 为散列表中的元素个数与散列表大小的比值。</p>
<h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>将散列到同一个值的所有元素保留到一个链表中。<br>一般法则：使 λ ≈ 1，控制链表的长度，若 λ &gt; 1 则通过再散列扩充</p>
<h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>不用链表存储，实现分配较大空间，称为<strong>探测散列表</strong><br>hi(x) = (hash(x) + f(i)) mod TableSize, f(0) = 0.<br>一般 λ &gt; 0.5 就要再散列</p>
<ul>
<li>线性探测 f(i) = i</li>
<li>平方探测 f(i) = i^2</li>
<li>双散列 f(i) = i * hash2(x), hash2(x) = R - (x mod R) 这样的函数会起作用，其中R为小于TableSize的素数</li>
</ul>
<h2 id="再散列-rehash"><a href="#再散列-rehash" class="headerlink" title="再散列(rehash)"></a>再散列(rehash)</h2><ol>
<li>只要表到一半就再散列</li>
<li>只有插入失败时才再散列</li>
<li>途中策略：当表到达某一个装填因子时进行再散列（最优）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;散列表（hash table）的实现通常称为散列（hashing），指用于以O(1)时间执行插入、删除和查找的技术，但不支持需要排序信息的树操作，比如findMin、findMax以及在线性时间内按顺序打印整个表都不支持&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（四）：树</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91/"/>
    <id>https://i-square.github.io/post/DS学习笔记-树/</id>
    <published>2017-03-31T14:05:29.000Z</published>
    <updated>2017-04-19T08:46:42.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>了解树是如何用于实现文件系统的</li>
<li>了解树如何用来计算算术表达式的值</li>
<li>了解如何用树实现O(logN)时间进行搜素</li>
<li>讨论并使用set和map</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul>
<li>前序：先处理自己后处理左右儿子</li>
<li>中序：先处理左儿子再处理自己再处理右儿子</li>
<li>后序：先处理左右儿子再处理自己</li>
</ul>
<h2 id="二叉查找树（平均深度O-logN-）"><a href="#二叉查找树（平均深度O-logN-）" class="headerlink" title="二叉查找树（平均深度O(logN)）"></a>二叉查找树（平均深度O(logN)）</h2><p>性质：对于树中的每个节点X，左子树中所有项的值小于X中的项，右子树中所有项的值大于X中的项<br>缺点：不能动态调整，若输入为已排序序列则构造出最坏情况下的斜树</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul>
<li>带有<strong>平衡条件</strong>的二叉查找树</li>
<li>一棵AVL树是每个节点的左子树和右子树的高度最多相差1的二叉查找树（空树高度定义为-1）</li>
<li>插入新节点可能破坏AVL树的平衡，需要通过<strong>旋转</strong>解决</li>
</ul>
<p>把需要平衡的节点叫α  </p>
<ol>
<li>对α的左儿子的左子树进行一次插入</li>
<li>对α的左儿子的右子树进行一次插入</li>
<li>对α的右儿子的左子树进行一次插入</li>
<li>对α的右儿子的右子树进行一次插入</li>
</ol>
<p>1和4（左左，右右）发生在外边，进行一次<strong>单旋转</strong>即可，2和3（左右，右左）则发生在内部，需要通过<strong>双旋转</strong>调整</p>
<h2 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h2><p>节点可以达到任意深度，每次访问某节点后把该节点调整为根节点，任意连续M次操作花费O(MlogN)时间</p>
<h2 id="B树（平衡M路树）"><a href="#B树（平衡M路树）" class="headerlink" title="B树（平衡M路树）"></a>B树（平衡M路树）</h2><p>M=3时：2-3树，实现平衡查找树的另一种方法</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>通过插入元素构造查找树，然后执行中序遍历，可以得到排序后的元素。<br>这是一种O(NlogN)的排序算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;了解树是如何用于实现文件系统的&lt;/li&gt;
&lt;li&gt;了解树如何用来计算算术表达式的值&lt;/li&gt;
&lt;li&gt;了解如何用树实现O(log
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MathType6.9b不兼容Office2016的解决办法</title>
    <link href="https://i-square.github.io/post/MathType6-9b%E4%B8%8D%E5%85%BC%E5%AE%B9Office2016%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://i-square.github.io/post/MathType6-9b不兼容Office2016的解决办法/</id>
    <published>2017-03-29T10:37:43.000Z</published>
    <updated>2017-03-29T10:55:39.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>安装MathType6.9b后打开Word2016，发现菜单栏里并没有集成MathType，想办法解决以后，菜单栏上已经集成了MathType，但是仍然不能用，每次打开Word都会弹框提示Mathpage.wll未找到，无奈又去网上找寻了解决办法，在这里记录一下，就当云笔记了。</p>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="Office2016支持"><a href="#Office2016支持" class="headerlink" title="Office2016支持"></a>Office2016支持</h3><p>Office2016需要在MathType根目录下添加文件MPlugin.dll，一般在安装文件夹里</p>
<h3 id="Mathpage-wll未找到问题"><a href="#Mathpage-wll未找到问题" class="headerlink" title="Mathpage.wll未找到问题"></a>Mathpage.wll未找到问题</h3><p>通过以下方法解决(以Office2016为例)：</p>
<ol>
<li>依次打开<code>Word→文件→选项→信任中心→信任中心设置→受信任位置→添加新位置</code><br>添加 <code>C:\Program Files\Microsoft Office\Office16\STARTUP</code>，然后关闭Word</li>
<li>在mathtype安装目录下找到以下2个文件(以64位系统为例):  <ul>
<li><code>C:\Program Files (x86)\MathType\MathPage\64\MathPage.wll</code></li>
<li><code>C:\Program Files (x86)\MathType\Office Support\64\MathType Commands 6 For Word 2016.dotm</code></li>
</ul>
</li>
<li>将两个文件分别拷贝到对应的文件夹中:  <ul>
<li>将<code>MathType Commands 6 For Word 2016.dotm</code> 拷贝到 <code>C:\Program Files\Microsoft Office\Office16\STARTUP</code></li>
<li>将 <code>MathPage.wll</code> 拷贝到 <code>C:\Program Files\Microsoft Office\Office16</code></li>
</ul>
</li>
<li>重新打开Word你会发现一切都OK了!</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;安装MathType6.9b后打开Word2016，发现菜单栏里并没有集成MathType，想办法解决以后，菜单栏上已经集成了MathType，但是仍然不能用，每次打开Word都会弹框提示Mathpage.wll未找到，无奈又去网上找寻了解决办法，在这里记录一下，就当云笔记了。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Office" scheme="https://i-square.github.io/tags/Office/"/>
    
      <category term="MathType" scheme="https://i-square.github.io/tags/MathType/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（三）：表、栈和队列</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://i-square.github.io/post/DS学习笔记-表、栈和队列/</id>
    <published>2017-03-27T07:27:43.000Z</published>
    <updated>2017-04-17T07:44:39.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>介绍三种基本的数据结构</li>
<li>介绍抽象数据类型(ADT, abstract data type)的概念</li>
<li>介绍栈ADT及其在实现递归方面的应用</li>
<li>介绍队列ADT及其在操作系统和算法设计中的应用</li>
<li>给出vector和list的重要子集的实现</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>栈是一个表，因此任何实现表的方法都能实现栈。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>符号平衡</li>
<li>后缀（逆波兰）表达式计算</li>
<li>中缀到后缀的转换</li>
<li>函数调用<br>（代码实现了一个简单的计算器，应保证输入合法）</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>ex 3.34 提示：判断一个链表是否有环，只使用O(1)的额外空间，使用两个迭代器p,q p每次递增1，q每次递增2，若q到了末尾则没环，否则pq必定在环中间相遇</p>
<p>也可用于快速找出单链表的中间节点</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;介绍三种基本的数据结构&lt;/li&gt;
&lt;li&gt;介绍抽象数据类型(ADT, abstract data type)的概念&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Office2016中右键无法打开Visio图像的解决办法</title>
    <link href="https://i-square.github.io/post/Office2016%E4%B8%AD%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80Visio%E5%9B%BE%E5%83%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://i-square.github.io/post/Office2016中右键无法打开Visio图像的解决办法/</id>
    <published>2017-03-26T07:21:56.000Z</published>
    <updated>2017-03-29T10:40:20.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在Office2016中，右键Visio图像，只有“转换”功能，而不再提供之前早期Office中提供的“打开”和“编辑”功能，那么，如何能够在Office2016中打开visio图像呢？</p>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在Visio图上使用 <code>ALT + 双击鼠标左键</code> 即可在Visio中打开<br>直接双击Visio图像则是和之前版本一样，在当前Office窗口中打开Visio图。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在Office2016中，右键Visio图像，只有“转换”功能，而不再提供之前早期Office中提供的“打开”和“编辑”功能，那么，如何能够在Office2016中打开visio图像呢？&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Office" scheme="https://i-square.github.io/tags/Office/"/>
    
      <category term="Visio" scheme="https://i-square.github.io/tags/Visio/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（二）：算法分析</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://i-square.github.io/post/DS学习笔记-算法分析/</id>
    <published>2017-03-25T14:48:53.000Z</published>
    <updated>2017-04-17T07:43:12.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>主要内容是复杂度分析</li>
<li>大O标记</li>
<li>计算大O时的一般法则<ul>
<li>对数规律的一般法则<br>如果一个算法用常数时间（O(1)）将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。</li>
</ul>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol>
<li>二分搜索提供了O(logN)的查找算法</li>
<li>最大公因数的欧几里得算法也是O(logN)的</li>
<li>幂运算的递归算法</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;主要内容是复杂度分析&lt;/li&gt;
&lt;li&gt;大O标记&lt;/li&gt;
&lt;li&gt;计算大O时的一般法则&lt;ul&gt;
&lt;li&gt;对数规律的一般法则&lt;b
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（一）：引论</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%95%E8%AE%BA/"/>
    <id>https://i-square.github.io/post/DS学习笔记-引论/</id>
    <published>2017-03-24T06:22:23.000Z</published>
    <updated>2017-04-19T08:46:49.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>介绍基本数学知识</li>
<li>简要复习递归</li>
<li>介绍用到的C++知识</li>
</ul>
<h2 id="递归的四条基本法则"><a href="#递归的四条基本法则" class="headerlink" title="递归的四条基本法则"></a>递归的四条基本法则</h2><ol>
<li>基准情形。必须总有某些基准情形不用递归就能求解。  </li>
<li>不断推进。对于那些需要递归求解的情形，递归调用必须总能够朝着基准情形的方向推进。  </li>
<li>设计法则。假设所有的递归调用都能运行。  </li>
<li>合成效益法则。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;介绍基本数学知识&lt;/li&gt;
&lt;li&gt;简要复习递归&lt;/li&gt;
&lt;li&gt;介绍用到的C++知识&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（零）：开始</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%A7%8B/"/>
    <id>https://i-square.github.io/post/DS学习笔记-开始/</id>
    <published>2017-03-23T03:23:54.000Z</published>
    <updated>2017-04-17T08:00:26.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了准备今年后半年到来的秋招，我决定开始学习数据结构，为后面的学习打基础，采用的教材是weiss的《数据结构与算法分析C++描述》，计划实现书上上的示例代码以及力所能及的课后习题。</p>
<p>在Github上同步源码，项目地址：<a href="https://github.com/i-square/Data-Structure" target="_blank" rel="external">https://github.com/i-square/Data-Structure</a></p>
<h2 id="学习环境"><a href="#学习环境" class="headerlink" title="学习环境"></a>学习环境</h2><ul>
<li>Windows 10 &amp; 8.1</li>
<li>Visual Studio 2015 with update 3</li>
<li>C++ (部分C++11语法)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为了准备今年后半年到来的秋招，我决定开始学习数据结构，为后面的学习打基础，采用的教材是weiss的《数据结构与算法分析C++描述》，计划实现
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
