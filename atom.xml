<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>平方君的后花园</title>
  <subtitle>Keep It Simple, Stupid.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://i-square.github.io/"/>
  <updated>2017-07-03T14:41:12.112Z</updated>
  <id>https://i-square.github.io/</id>
  
  <author>
    <name>平方君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OneDriveSetup.exe占用大量CPU的解决办法</title>
    <link href="https://i-square.github.io/post/OneDriveSetup-exe%E5%8D%A0%E7%94%A8%E5%A4%A7%E9%87%8FCPU%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://i-square.github.io/post/OneDriveSetup-exe占用大量CPU的解决办法/</id>
    <published>2017-07-03T14:27:29.000Z</published>
    <updated>2017-07-03T14:41:12.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从前两周开始我的实验室电脑出现了CPU占用率一直保持在25%以上的现象，经过排查发现问题出在<code>OneDriveSetup.exe</code>这个进程上，然而当时我上谷歌各种搜索也没有找到解决办法，后来也就没管，但是今天无意中正好看到解决办法，在这里分享出来，希望遇到这个问题的能够尽早解决。</p>
<a id="more"></a>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决办法最早是在德国微软论坛里发布的，发布时间是2017年6月26日，这里是<a href="https://answers.microsoft.com/de-de/windows/forum/windows_10-performance/onedrivesetupexe-32bit-lastet-cpu-dauerhaft-mit-ca/ae516fe5-7b88-4e87-bf37-fbc94d1a7664" target="_blank" rel="external">原帖地址</a></p>
<p>以下是操作步骤：</p>
<ol>
<li>在任务管理器里面结束进程<code>OneDriveSetup.exe</code></li>
<li>进入<code>C:\Users\your username\AppData\Local\Microsoft\OneDrive\setup\logs</code>文件夹，删除以下2个文件(如果看不到这两个文件，需要先设置显示隐藏文件和显示系统文件)<ul>
<li><code>UserTelemetryCache.otc</code></li>
<li><code>UserTelemetryCache.otc.session</code></li>
</ul>
</li>
<li>删除后进入<code>C:\Users\your username\AppData\Local\Microsoft\OneDrive\Update</code>文件夹运行里面的<code>OneDriveSetup.exe</code>安装更新即可</li>
</ol>
<p>这个时间<code>OneDriveSetup.exe</code>不会在占用大量CPU，也不会一直在后台跑了，enjoy</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从前两周开始我的实验室电脑出现了CPU占用率一直保持在25%以上的现象，经过排查发现问题出在&lt;code&gt;OneDriveSetup.exe&lt;/code&gt;这个进程上，然而当时我上谷歌各种搜索也没有找到解决办法，后来也就没管，但是今天无意中正好看到解决办法，在这里分享出来，希望遇到这个问题的能够尽早解决。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Win10" scheme="https://i-square.github.io/tags/Win10/"/>
    
      <category term="OneDrive" scheme="https://i-square.github.io/tags/OneDrive/"/>
    
  </entry>
  
  <entry>
    <title>MFC+BCG库静态链接方法总结</title>
    <link href="https://i-square.github.io/post/MFC-BCG%E5%BA%93%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://i-square.github.io/post/MFC-BCG库静态链接方法总结/</id>
    <published>2017-06-19T14:24:59.000Z</published>
    <updated>2017-06-19T15:05:29.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个MFC项目，使用了有名的BCG界面库，我的编程平台是<code>Win10 + VS2015</code>, 在我自己的机器上测试的时候一直都是使用动态链接的方式，没有什么问题，但是当切换到<code>Windows Server 2008 R2</code>系统下，会出现缺少<code>xxx.dll</code>的错误，按照往常的做法，缺少的文件也就是VC的运行库，然而我安装VS2015的运行库却失败了，网上一查才发现VS2015的运行时库不支持<code>Windows Server 2008 R2</code>，最低得是<code>Windows Server 2008 R2 with SP1</code>，安装运行库的法子走不通，只能换一条路了。</p>
<a id="more"></a>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>MFC程序可以用动态链接或者静态链接的方式使用MFC的库，动态链接的好处是最后生成的exe文件非常小，缺点是目标机器必须安装对应的运行库，或者要在文件夹里手动放入所需的dll；静态链接的好处是直接把VC的运行库链接到最终的exe里，不必安装运行库或者添加一堆dll就可以直接运行，缺点是生成的exe会比较大。</p>
<p>静态链接多占用的那一点空间对我来说没什么影响，所以我打算采取静态链接的方法解决上面提到的问题，MFC的库好办，只需要改项目属性就可以了，而静态链接BCG库则多一点波折，关于如何静态链接BCG库网上也有很多方法，但是并不全面，经过一番查找，我自己总结了在MFC里静态链接BCG库的方法，内容主要参考自<a href="https://support.bcgsoft.com/KB/Category/19-technical-questions" target="_blank" rel="external">BCG技术问答</a>里的<a href="https://support.bcgsoft.com/KB/View/37-how-can-i-add-a-library-to-my-static-mfc-project" target="_blank" rel="external">这个问题</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li>编译所需版本的静态库lib文件（这一步在安装BCG库的时候一般做过了，直接拷贝出来就行，如<code>BCGCBPRO2510STATICU140.lib</code>）</li>
</ol>
<ul>
<li>修改项目属性<ul>
<li><code>C/C++</code>-&gt;<code>代码生成</code>-&gt;<code>运行库</code>里选择<code>MT</code>(release)或者<code>MTd</code>(debug)</li>
<li><code>常规</code>里选择<code>在静态库中使用 MFC</code></li>
</ul>
</li>
<li>将BCGSoft\BCGControlBarPro\BCGCBPro\Styles下的<ul>
<li><code>Office 2010 (blue)</code>文件夹(以该主题为例)</li>
<li><code>BCGPStyle2010Blue.rc</code>和<code>BCGPStyle2010Blue.rc2</code>文件</li>
</ul>
</li>
<li>拷贝到<code>你的项目主目录</code></li>
</ul>
<h3 id="修改stdafx-cpp"><a href="#修改stdafx-cpp" class="headerlink" title="修改stdafx.cpp"></a>修改<code>stdafx.cpp</code></h3><p>在<code>stdafx.cpp</code>文件的最后（在<code>#include stdafx.h</code>之后）添加以下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt; 1500</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPILE_MULTIMON_STUBS</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable: 4996)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"multimon.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="修改资源文件属性"><a href="#修改资源文件属性" class="headerlink" title="修改资源文件属性"></a>修改资源文件属性</h3><p>在资源视图的对话框上点击右键，选择<code>资源包括(L)...</code></p>
<ol>
<li>在<code>只读符号指令</code>里添加<code>#include &quot;bcgprores.h&quot;</code></li>
</ol>
<ul>
<li>在<code>编译时指令</code>里<ul>
<li>移除<code>_AFX_NO_SPLITTER_RESOURCES</code></li>
<li>添加<code>#include &quot;BCGCBPro.rc&quot;</code>和<code>#include &quot;BCGPStyle2010Blue.rc&quot;</code></li>
<li>如果你想动态链接MFC，静态链接BCG, 则添加<code>&quot;#define _BCGCBPRO_STATIC_&quot;</code></li>
</ul>
</li>
</ul>
<ul>
<li>(这条基本不用管)如果你的项目是从MFC版本2008或更高版本移植的，请删除资源文件中对<code>afxribbon.rc</code>的所有引用，因为它和<code>BCGCBPro.rc</code>冲突</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在做一个MFC项目，使用了有名的BCG界面库，我的编程平台是&lt;code&gt;Win10 + VS2015&lt;/code&gt;, 在我自己的机器上测试的时候一直都是使用动态链接的方式，没有什么问题，但是当切换到&lt;code&gt;Windows Server 2008 R2&lt;/code&gt;系统下，会出现缺少&lt;code&gt;xxx.dll&lt;/code&gt;的错误，按照往常的做法，缺少的文件也就是VC的运行库，然而我安装VS2015的运行库却失败了，网上一查才发现VS2015的运行时库不支持&lt;code&gt;Windows Server 2008 R2&lt;/code&gt;，最低得是&lt;code&gt;Windows Server 2008 R2 with SP1&lt;/code&gt;，安装运行库的法子走不通，只能换一条路了。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MFC" scheme="https://i-square.github.io/tags/MFC/"/>
    
      <category term="BCG库" scheme="https://i-square.github.io/tags/BCG%E5%BA%93/"/>
    
      <category term="静态链接" scheme="https://i-square.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用C++11实现一个简易计时器类</title>
    <link href="https://i-square.github.io/post/%E4%BD%BF%E7%94%A8C++11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E8%AE%A1%E6%97%B6%E5%99%A8%E7%B1%BB/"/>
    <id>https://i-square.github.io/post/使用C++11实现一个简易计时器类/</id>
    <published>2017-05-22T12:59:21.000Z</published>
    <updated>2017-06-21T08:41:33.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>计时器可能是大多数程序员都自己实现过的一个功能，尤其是<code>C++</code>这种没有计时器类可以直接调用的，一般都会自己实现一个，而由于硬件的原因，想要一个跨平台的计时器功能还要兼顾不同的硬件平台，增加程序员的工作量。<code>C++11</code>标准发布之后，新增了<code>chrono</code>命名空间，里面包含了大量与时间相关的功能，利用它可以非常方便的写出一个计时器类。</p>
<a id="more"></a>
<h2 id="旧式计时器类"><a href="#旧式计时器类" class="headerlink" title="旧式计时器类"></a>旧式计时器类</h2><p>先说一下以往的方法，在<code>Windows</code>平台上，想要实现一个高精度的计时器，一般会用到2个<code>Windows API</code>，<code>QueryPerformanceFrequency</code>和<code>QueryPerformanceCounter</code>，配合使用获取高精度时间间隔。而<code>linux</code>平台则一般使用<code>gettimeofday</code>函数，可以获取微妙精度的时间，如需更高精度，则可能要用到汇编。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>它可能长这样，为了兼顾不同平台，需要预处理宏的帮忙。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_WINSOCK2API_) &amp;&amp; !defined(_WINSOCKAPI_)</span></div><div class="line"><span class="keyword">struct</span> timeval &#123;</div><div class="line">    <span class="keyword">long</span> tv_sec;</div><div class="line">    <span class="keyword">long</span> tv_usec;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//_WIN32</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_WIN32</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> timer_dt;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Timer &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Timer();</div><div class="line">	~Timer() &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</div><div class="line">	<span class="function">timer_dt <span class="title">get_time</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line">	<span class="keyword">double</span> freq;</div><div class="line">	LARGE_INTEGER start_time;</div><div class="line">	LARGE_INTEGER finish_time;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//_WIN32</span></span></div><div class="line">	<span class="keyword">struct</span> timeval start_time;</div><div class="line">	<span class="keyword">struct</span> timeval finish_time;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_WIN32</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>核心的3个函数<code>start()</code>、<code>stop()</code>和<code>get_time()</code>的实现可能是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数里获取高精度时钟的频率</span></div><div class="line">Timer::Timer() &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line">	LARGE_INTEGER tmp;</div><div class="line">	QueryPerformanceFrequency((LARGE_INTEGER*)&amp;tmp);</div><div class="line">	freq = (<span class="keyword">double</span>)tmp.QuadPart/<span class="number">1000.0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> Timer::start() &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line">	QueryPerformanceCounter((LARGE_INTEGER*) &amp;start_time);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//_WIN32</span></span></div><div class="line">	gettimeofday(&amp;start_time, <span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_WIN32</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> Timer::stop() &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line">	QueryPerformanceCounter((LARGE_INTEGER*) &amp;finish_time);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//_WIN32</span></span></div><div class="line">	gettimeofday(&amp;finish_time, <span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_WIN32</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line">timer_dt Timer::get_time() &#123;</div><div class="line">	timer_dt interval = <span class="number">0.0f</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></div><div class="line">	interval = (timer_dt)((<span class="keyword">double</span>)(finish_time.QuadPart</div><div class="line">		- start_time.QuadPart)	/ freq);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">	<span class="comment">// time difference in milli-seconds</span></div><div class="line">	interval = (timer_dt) (<span class="number">1000.0</span> * ( finish_time.tv_sec - start_time.tv_sec)</div><div class="line">		+(<span class="number">0.001</span> * (finish_time.tv_usec - start_time.tv_usec)));</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_WIN32</span></span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> interval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-11-计时器类"><a href="#C-11-计时器类" class="headerlink" title="C++11 计时器类"></a>C++11 计时器类</h2><h3 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h3><p><code>C++11</code>标准发布之后，给我们带来了<code>chrono</code>命名空间，里面的东西虽说名字特别难记:P，但是用起来很方便，用它来实现一个跨平台、高精度的计时器类只需要十几行代码，甚至核心代码只有3行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="comment">// 这里为了方便说明直接用了该命名空间，实际情况请酌情使用</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Timer &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Timer() : tpStart(high_resolution_clock::now()), tpStop(tpStart) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; tpStart = high_resolution_clock::now(); &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; tpStop = high_resolution_clock::now(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> span&gt;</div><div class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">delta</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> duration_cast&lt;span&gt;(high_resolution_clock::now() - tpStart).count(); &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    time_point&lt;high_resolution_clock&gt; tpStart;</div><div class="line">    time_point&lt;high_resolution_clock&gt; tpStop;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>没错，只需要这些代码就可以实现一个跨平台且高精度的计时器类，使用方法也非常简单，可以按需选择精度，例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Timer t;</div><div class="line"><span class="comment">// some code here</span></div><div class="line">t.stop();</div><div class="line"><span class="comment">// 调用 delta() 函数时需指定精度，以下四种均在chrono命名空间内定义</span></div><div class="line"><span class="comment">// seconds, milliseconds, microseconds, nanoseconds</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the xxx time is: "</span> &lt;&lt; t.delta&lt;nanoseconds&gt;() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出纳秒</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the xxx time is: "</span> &lt;&lt; t.delta&lt;milliseconds&gt;() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出毫秒</span></div></pre></td></tr></table></figure>
<p>为了方便使用，还可以加入以下两个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> span&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">stop_delta</span><span class="params">()</span> </span>&#123; stop(); <span class="keyword">return</span> duration_cast&lt;span&gt;(tpStop - tpStart).count(); &#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> span&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">stop_delta_start</span><span class="params">()</span> </span>&#123;</div><div class="line">    stop();</div><div class="line">    <span class="keyword">auto</span> ts = duration_cast&lt;span&gt;(tpStop - tpStart).count();</div><div class="line">    start();</div><div class="line">    <span class="keyword">return</span> ts;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h3><p>C++11还增加了<code>ratio</code>命名空间，顾名思义，这个命名空间里定义了一堆比率，如<code>std::milli</code>、<code>std::micro</code>、<code>std::nano</code>，配合这些比率我们就可以实现一个返回浮点数的计时器了，核心代码如下，只是修改了一点点内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></div><div class="line"><span class="comment">// 这里为了方便说明直接用了该命名空间，实际情况请酌情使用</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Timer &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> s = <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ms = <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;;</div><div class="line">    <span class="keyword">using</span> us = <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;;</div><div class="line">    <span class="keyword">using</span> ns = <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt;;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Timer() : tpStart(high_resolution_clock::now()), tpStop(tpStart) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; tpStart = high_resolution_clock::now(); &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; tpStop = high_resolution_clock::now(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> span&gt;</div><div class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">delta</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> duration&lt;<span class="keyword">double</span>, span&gt;(high_resolution_clock::now() - tpStart).count(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> span&gt;</div><div class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">stop_delta</span><span class="params">()</span> </span>&#123; stop(); <span class="keyword">return</span> duration&lt;<span class="keyword">double</span>, span&gt;(tpStop - tpStart).count(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> span&gt;</div><div class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">stop_delta_start</span><span class="params">()</span> </span>&#123;</div><div class="line">        stop();</div><div class="line">        <span class="keyword">auto</span> ts = duration&lt;<span class="keyword">double</span>, span&gt;(tpStop - tpStart).count();</div><div class="line">        start();</div><div class="line">        <span class="keyword">return</span> ts;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    time_point&lt;high_resolution_clock&gt; tpStart;</div><div class="line">    time_point&lt;high_resolution_clock&gt; tpStop;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++11新增的这个<code>chrono</code>命名空间非常方便好用，由于是标准库，在跨平台方面具有天然优势，在代码简洁程度上也比原来要好，配合模板更加可以减少代码量，当然它不止能用来做计时器用，还有很多别的方面的应用，在此就不多说了，以后可能会补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;计时器可能是大多数程序员都自己实现过的一个功能，尤其是&lt;code&gt;C++&lt;/code&gt;这种没有计时器类可以直接调用的，一般都会自己实现一个，而由于硬件的原因，想要一个跨平台的计时器功能还要兼顾不同的硬件平台，增加程序员的工作量。&lt;code&gt;C++11&lt;/code&gt;标准发布之后，新增了&lt;code&gt;chrono&lt;/code&gt;命名空间，里面包含了大量与时间相关的功能，利用它可以非常方便的写出一个计时器类。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++11" scheme="https://i-square.github.io/tags/C-11/"/>
    
      <category term="计时器" scheme="https://i-square.github.io/tags/%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（八）：不相交集类</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB/"/>
    <id>https://i-square.github.io/post/DS学习笔记-不相交集类/</id>
    <published>2017-04-24T07:42:58.000Z</published>
    <updated>2017-04-24T07:43:04.961Z</updated>
    
    <content type="html"><![CDATA[<p>这一章介绍解决等价问题的一种有效数据结构。实现简单，也非常快，每种操作只需要常数平均时间。</p>
<h2 id="等价关系-equivalence-relation"><a href="#等价关系-equivalence-relation" class="headerlink" title="等价关系 (equivalence relation)"></a>等价关系 (equivalence relation)</h2><p>若对于每一对元素(a,b),a,b∈S, <code>a R b</code>或者为true或者为false，则称在集合S上定义关系R。如果<code>a R b</code>为true，我们说a和b有关系。</p>
<p><strong>等价关系</strong>是满足下列三个性质的关系R：</p>
<ol>
<li>自反性：对于所有的a∈S，<code>a R a</code></li>
<li>对称性：<code>a R b</code>当且仅当<code>b R a</code></li>
<li>传递性：若<code>a R b</code>且b R c则<code>a R c</code></li>
</ol>
<p>元素a∈S的<strong>等价类</strong>(equivalence class)是S的子集，它包含所有与a有（等价）关系的元素。注意，等价类形成对S的一个划分：S的每一个成员恰好出现在一个等价类中。为确定是否a~b，我们只需验证a和b是否都在同一个等价类中。</p>
<p>输入数据最初是N个集合(collection)的类，每个集合含有一个元素。初始的描述是所有的关系均为false（自反的关系除外）。每个集合都有一个不同的元素，从而<code>Si∩Sj=⊙</code>，称为<strong>不相交</strong>(disjoint)</p>
<p>基本操作有两种，称为<strong>求并/查找</strong>(union/find)算法。</p>
<h2 id="灵巧求并算法"><a href="#灵巧求并算法" class="headerlink" title="灵巧求并算法"></a>灵巧求并算法</h2><p>直观的union操作相当随意，它简单地通过使第二棵树成为第一棵树的子树而完成合并。对其进行简单改进，使得总是较小的树成为较大的树的子树，称为<strong>按大小求并</strong>(union by size)，它保证树的深度最大是O(logN)。<br>连续M次操作平均需要O(M)时间。</p>
<p>另一种方法是<strong>按高度求并</strong>(union by height)，它同样保证树的深度最大是O(logN)。做法是使浅的树成为深的树的子树。</p>
<h2 id="一个应用"><a href="#一个应用" class="headerlink" title="一个应用"></a>一个应用</h2><p>应用求并/查找数据结构的一个例子是迷宫的生成。初始化时所有格子都在自己的等价类中，之后不断合并，最终生成迷宫。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章介绍解决等价问题的一种有效数据结构。实现简单，也非常快，每种操作只需要常数平均时间。&lt;/p&gt;
&lt;h2 id=&quot;等价关系-equivalence-relation&quot;&gt;&lt;a href=&quot;#等价关系-equivalence-relation&quot; class=&quot;headerli
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（七）：排序</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F/"/>
    <id>https://i-square.github.io/post/DS学习笔记-排序/</id>
    <published>2017-04-23T14:01:12.000Z</published>
    <updated>2017-04-24T03:25:11.779Z</updated>
    
    <content type="html"><![CDATA[<p>在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。<br>假设输入数据支持”&lt;”和”&gt;”操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>对内部排序的考查将指出：</p>
<ul>
<li>存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序</li>
<li>希尔排序编程简单，以o(N^2)运行，在实践中很有效</li>
<li>还有一些稍微复杂的O(NlogN)算法</li>
<li>任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较</li>
</ul>
<h2 id="插入排序-insertion-sort"><a href="#插入排序-insertion-sort" class="headerlink" title="插入排序 (insertion sort)"></a>插入排序 (insertion sort)</h2><p>插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>O(N^2) 精确界，反序输入可达。<br>若已排序输入，则O(N)<br>平均情形Θ(N^2)</p>
<h2 id="一些简单排序算法的下界"><a href="#一些简单排序算法的下界" class="headerlink" title="一些简单排序算法的下界"></a>一些简单排序算法的下界</h2><p>定理1 N个互异元素的数组的平均逆序数是N(N-1)/4<br>定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间<br>对冒泡排序、选择排序、插入排序都有效<br>定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。</p>
<h2 id="希尔排序-shell-sort"><a href="#希尔排序-shell-sort" class="headerlink" title="希尔排序 (shell sort)"></a>希尔排序 (shell sort)</h2><p>发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。</p>
<p>它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做<strong>缩减增量排序</strong>(diminishing increment sort)</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>使用希尔增量的最坏情形Θ(N^2)<br>Hibbard增量：1，3，7，…… ，2^k - 1<br>使用Hibbard增量的最坏情形Θ(N^(3/2))<br>Sedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))<br>希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。</p>
<h2 id="堆排序-heap-sort"><a href="#堆排序-heap-sort" class="headerlink" title="堆排序 (heap sort)"></a>堆排序 (heap sort)</h2><p>如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序</p>
<p>由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)<br>使用了附加数组，存储需求增加了一倍</p>
<p>避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆</p>
<ol>
<li>以O(N)建立max堆</li>
<li>交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax</li>
<li>循环执行步骤2，N-1次</li>
</ol>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>在最坏情形下堆排序最多使用2NlogN-O(N)次比较<br>堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少</p>
<p>定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN)</p>
<p>可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明</p>
<h2 id="归并排序-merge-sort"><a href="#归并排序-merge-sort" class="headerlink" title="归并排序 (merge sort)"></a>归并排序 (merge sort)</h2><p>以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例</p>
<p>算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>基准情形：N=1时，结果是显然的<br>否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并</p>
<p>该算法是经典的<strong>分治</strong>策略，它将问题<strong>分</strong>(divide)成一些小问题然后递归求解，而<strong>治</strong>(conquering)的阶段则是将分的阶段解得的各答案合并在一起</p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。<br>假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有<br>T(1) = 1<br>T(N) = 2T(N/2) + N<br>求解得 T(N) = NlogN + N = O(NlogN)</p>
<p>利弊：在java中比较耗时多于移动，因此在java中归并排序是一般目的排序的最佳选择；但在C++中，比较耗时少而复制对象代价很大，因此实践中不常用</p>
<h2 id="快速排序-quick-sort"><a href="#快速排序-quick-sort" class="headerlink" title="快速排序 (quick sort)"></a>快速排序 (quick sort)</h2><p>快排是实践中最快的已知排序算法，平均运行时间是O(NlogN)，最坏情形是O(N^2)，但稍作努力就可避免。<br>通过将堆排序与快速排序结合，可以在堆排序O(NlogN)最坏运行时间下，得到几乎所有输入的最快运行时间。</p>
<p>快排也是分治的递归算法，排序数组S步骤如下：</p>
<ol>
<li>若S中元素数是0或1，则返回</li>
<li>取S中任一元素v，称之为<strong>枢纽元</strong>(pivot)</li>
<li>将S-{v}（S中其余元素）<strong>划分</strong>成两个不相交的集合：S1={x∈S-{v}|x≤v}和S2={x∈S-{v}|x≥v}</li>
<li>返回{quickSort(S1),后跟v,继而quickSort(S2)}</li>
</ol>
<p>第三步中划分的标准不是唯一的，因此这就成了设计决策。一部分好的实现方法是将这种情形尽可能有效地处理。直观地看，我们希望枢纽元能将元素对半分，一半在S1，另一半在S2。</p>
<h3 id="选取枢纽元"><a href="#选取枢纽元" class="headerlink" title="选取枢纽元"></a>选取枢纽元</h3><ol>
<li>一种典型的错误是将第一个元素选作枢纽元。若输入随机，那么这是可以接受的，但实际情况有很多预排序的序列，这样的分割是劣质的。类似的还有选取前2个元素的大者，这是一样的，不要使用。</li>
<li>一种安全的做法是随机选取枢纽元，但这取决于随机数生成器的质量，而且声称随机数的代价一般也是很昂贵的。</li>
<li>三数中值分割法<br>一组N个数的中值是第上取整(N/2)个最大的数。枢纽元的最好选择是数组的中值，但算出中值代价太高。一般的做法是选取左端、右端和中心位置上的三个元素的中值作为枢纽元。显然该方法消除了预排序输入的不好情形，并且减少了约14%的比较次数。</li>
</ol>
<h3 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h3><ol>
<li>将枢纽元与最后的元素交换</li>
<li>i从第一个元素开始，j从倒数第二个元素开始</li>
<li>当i在j左边时，右移i，移过小于枢纽元的元素，j左移，移过大于枢纽元的元素，i,j都停止时交换两个元素，直到i,j交错</li>
<li>将枢纽元与i所指向的元素交换</li>
</ol>
<p>如何处理等于枢纽元的元素？<br>若等于，则停止移动</p>
<h3 id="小数组"><a href="#小数组" class="headerlink" title="小数组"></a>小数组</h3><p>对于很小的数组（N≤20），快速排序不如插入排序，而且，因为快排是递归的，这样的情形经常发生。通常的解决办法是，对于小数组使用插入排序。一种好的截止范围(cutoff range)是N=10</p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最坏情形：O(N^2)<br>最佳情形：O(NlogN)<br>平均情形：O(NlogN)</p>
<h2 id="快速选择-quick-select"><a href="#快速选择-quick-select" class="headerlink" title="快速选择 (quick select)"></a>快速选择 (quick select)</h2><p>修改快速排序以解决选择问题，即找第k个最大（小）元。</p>
<p>前3步和快速排序一样<br>第4步</p>
<ul>
<li>若k≤S1，那么k必然在S1中，返回quickSelect(S1, K)</li>
<li>若k = 1 + |S1|，那么枢纽元就是第k个最小元</li>
<li>否则，第k个最小元就在S2中，它是S2中的第（k-|S1|-1）个最小元，返回quickSelect(S2, k-|S1|-1)</li>
</ul>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>与快排相比，快速选择只进行了一次递归调用而不是两次</p>
<p>最坏情形：O(N^2)，当S1和S2一个是空时<br>平均情形：O(N)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。&lt;br&gt;假设输入数据支持”&amp;lt;”和”&amp;gt;”操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; cl
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（六）：优先队列（堆）</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A0%86%EF%BC%89/"/>
    <id>https://i-square.github.io/post/DS学习笔记-优先队列（堆）/</id>
    <published>2017-04-20T14:27:15.000Z</published>
    <updated>2017-04-20T14:27:48.633Z</updated>
    
    <content type="html"><![CDATA[<p>本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用<br>作者评价：这类数据结构属于计算机科学中最雅致的一种</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>优先队列ADT的高效实现</li>
<li>优先队列的使用</li>
<li>优先队列的高级实现</li>
</ul>
<h2 id="二叉堆-binary-heap"><a href="#二叉堆-binary-heap" class="headerlink" title="二叉堆 (binary heap)"></a>二叉堆 (binary heap)</h2><p>插入删除最坏O(logN)，实际上插入花费常数平均时间，若无删除干扰，该结构将以线性时间建立一个具有N项的优先队列。<br>与二叉查找树一样，堆具有两个性质，堆的操作必须满足所有性质才能终止。</p>
<h3 id="结构性质"><a href="#结构性质" class="headerlink" title="结构性质"></a>结构性质</h3><p>堆是一棵<strong>完全二叉树</strong>（三角形缺右下角），特例是满二叉树（三角形），最底层元素必须从左往右填入，如有空缺则不是完全二叉树<br>一棵高为h的完全二叉树有[2^h , 2^(h+1) - 1]个节点，这意味着完全二叉树的高是 下取整(logN)，显然它是O(logN)的<br>因为此规律，所以堆可以用数组表示而不用链表，对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的(2i+1)上，它的父亲在位置 下取整(i/2) 上</p>
<h3 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h3><p>在堆中，除根节点以外，每一个节点的值都大于（或等于）它的父节点的值<br>根据堆序性质，最小值总在根结点，因此可以以O(1)时间做findMin<br>相应地，通过改变堆序性质，也可以建立一个max堆，以O(1)时间做findMax</p>
<h3 id="插入（上滤策略）"><a href="#插入（上滤策略）" class="headerlink" title="插入（上滤策略）"></a>插入（上滤策略）</h3><p>为了插入新元素X，在堆的下一个可用位置（为了满足结构性质）创建一个空穴，若X放入空穴仍满足堆序性质，则插入完成，否则交换空穴和其父节点，直到X被放入并满足堆序性质为止</p>
<h3 id="删除（下滤策略）"><a href="#删除（下滤策略）" class="headerlink" title="删除（下滤策略）"></a>删除（下滤策略）</h3><p>找出最小元很容易，难的是删除它。<br>当删除一个最小元时，堆中最后一个元素X必须移动到该堆的某个地方。策略是在根节点建立一个空穴，然后将两个儿子中的较小者移入空穴，重复该步骤直到X可以被放入空穴中。代码中则是用X直接替换根结点的值，然后下滤。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在堆的实现中经常出现的错误是，当堆中存在偶数个元素时，将出现一个节点只有一个儿子的情况。因此我们必须以节点不总有两个儿子为前提，这需要额外的测试。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h4><p>输入N个元素及整数k，找出第k个最大的元素，极端情况是k=上取整(N/2)，此时实际上是找中位数，以下两个算法都能在找中位数的情况下以O(NlogN)时间运行</p>
<ul>
<li>A 将N个元素读入数组，对数组应用buildHeap，再执行k次deleteMin，最后根节点上的就是第k个最小值，构造一个最大堆就可以找到第k个最大值</li>
<li>B 用buildHeap将前k个元素构造成一个最大堆，若下一个元素大于堆里的最小值，则删除最小值，插入新元素，最终的最小值就是所求的第k个最大值</li>
</ul>
<h2 id="d堆"><a href="#d堆" class="headerlink" title="d堆"></a>d堆</h2><p>类似B树，深度变浅，每个节点有d个儿子</p>
<h2 id="左式堆-leftist-heap"><a href="#左式堆-leftist-heap" class="headerlink" title="左式堆 (leftist heap)"></a>左式堆 (leftist heap)</h2><p>左式堆也是二叉树，但它不是理想平衡的，事实上是趋于非常不平衡</p>
<p>定义任一节点X的<strong>零路径长(null path length)</strong>npl(X)为从X到一个不具有两个儿子的节点的最短路径长<br>因此，具有0个或1个儿子的节点npl为0，而npl(NULL)=-1<br>注意，任一节点的npl比它儿子节点的npl的最小值多1</p>
<h3 id="左式堆性质"><a href="#左式堆性质" class="headerlink" title="左式堆性质"></a>左式堆性质</h3><p>对于堆中的每一个节点X，左儿子的npl至少与右儿子的npl一样大<br>这个性质导致树向左增加深度，沿左式堆右侧的右路径是堆中最短的路径<br>定理：在右路径上有r个节点的左式堆必然至少有2^r -1个节点</p>
<p>对左式堆的基本操作是合并。插入可以看成是合并一个单节点堆，删除即是删掉根结点，然后合并左右子树。</p>
<h2 id="斜堆-skew-heap"><a href="#斜堆-skew-heap" class="headerlink" title="斜堆 (skew heap)"></a>斜堆 (skew heap)</h2><p>斜堆是左式堆的自调节形式，具有堆序，但不存在结构限制。斜堆不需要存储npl，每次合并无条件交换左右儿子。</p>
<h2 id="二项队列-binomial-queue"><a href="#二项队列-binomial-queue" class="headerlink" title="二项队列 (binomial queue)"></a>二项队列 (binomial queue)</h2><p>以最坏O(logN)支持插入、合并、deleteMin，插入操作平均花费常数时间</p>
<p>实质是由<strong>二项树</strong>(binomial tree)构成的<strong>森林</strong>(forest)。<br>每一个高度上最多存在一棵二项树。高度为k的二项树Bk是通过将一棵二项树B(k-1)附接到另一棵二项树B(k-1)的根上构成的。高度为k的二项树有2^k个节点，在深度d处的节点数是二项系数C(d,k)</p>
<p>如果把堆序性质施加到二项树上并允许任意高度上最多一棵二项树，则可以用二项树的集合唯一地表示任意大小的优先队列。如大小为13的优先队列可以用B3,B2,B0表示，可以写成1101，同时也是13的二进制形式。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>基本操作仍然是合并，思想是从小到大合并相同高度的二项树<br>插入是特殊情况下的合并<br>deleteMin将原二项队列一分为二，再合并</p>
<p>编程需要注意<strong>进位</strong>的实现</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用&lt;br&gt;作者评价：这类数据结构属于计算机科学中最雅致的一种&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C盘根目录下的两个sys文件说明</title>
    <link href="https://i-square.github.io/post/C%E7%9B%98%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AAsys%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
    <id>https://i-square.github.io/post/C盘根目录下的两个sys文件说明/</id>
    <published>2017-04-19T08:24:22.000Z</published>
    <updated>2017-04-19T08:43:58.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实验室里有一台高配工作站，内存有512GB，用一块256GB的SSD安装Win7 x64操作系统以后，硬盘空间只剩下几十MB了，查看C盘下的文件之后，发现有两个隐藏的系统文件占用了200GB+的空间，于是马上查了它们的来头。</p>
<a id="more"></a>
<h2 id="pagefile-sys"><a href="#pagefile-sys" class="headerlink" title="pagefile.sys"></a>pagefile.sys</h2><p><code>pagefile.sys</code>是系统安装过程中创建的虚拟内存页面文件。这个文件的大小是自己系统虚拟内存设置的最小值的大小。假如虚拟内存的设置为800MB－1600MB 那么你在自己的设定驱动盘下面就可看到大小为800MB的<code>pagefile.sys</code>文件。</p>
<h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>通常自己可以在<code>我的电脑</code>右键<code>属性</code>–&gt;<code>高级</code>–&gt;<code>性能</code>–&gt;<code>高级</code>–&gt;<code>虚拟内存</code>中将所有盘的虚拟内存设置为无分页文件，并选择<code>设置</code>后重启系统，就可以删除页面文件<code>pagefile.sys</code>。</p>
<h2 id="hiberfil-sys"><a href="#hiberfil-sys" class="headerlink" title="hiberfil.sys"></a>hiberfil.sys</h2><p>这个文件是系统的休眠功能所占用的硬盘空间的文件（Windows默认休眠功能是处于打开状态的），电脑处于休眠状态时，内存中的所有内容将保存到硬盘，并且电脑会被关闭。电脑在返回打开状态之后，关闭电脑时打开的所有程序和文档将全都还原到桌面。也就是说，当你让电脑进入休眠状态时，Windows在关闭系统前将所有的内存内容写入<code>hiberfil.sys</code>文件，当你重新打开电脑，操作系统使用<code>hiberfil.sys</code>把所有信息放回内存，电脑恢复到关闭前的状态。然而，只要休眠功能开启，Windows就会在硬盘上留下<code>hiberfil.sys</code>文件，即使你从来不休眠。</p>
<h3 id="优化方法-1"><a href="#优化方法-1" class="headerlink" title="优化方法"></a>优化方法</h3><p>以管理员身份运行CMD，然后输入命令<code>powercfg -h off</code>，回车后立即生效，<code>hiberfil.sys</code>文件已经不见了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;实验室里有一台高配工作站，内存有512GB，用一块256GB的SSD安装Win7 x64操作系统以后，硬盘空间只剩下几十MB了，查看C盘下的文件之后，发现有两个隐藏的系统文件占用了200GB+的空间，于是马上查了它们的来头。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Windows" scheme="https://i-square.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（五）：散列</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%A3%E5%88%97/"/>
    <id>https://i-square.github.io/post/DS学习笔记-散列/</id>
    <published>2017-04-07T14:48:51.000Z</published>
    <updated>2017-04-19T08:46:25.022Z</updated>
    
    <content type="html"><![CDATA[<p>散列表（hash table）的实现通常称为散列（hashing），指用于以O(1)时间执行插入、删除和查找的技术，但不支持需要排序信息的树操作，比如findMin、findMax以及在线性时间内按顺序打印整个表都不支持</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>中心数据结构是<strong>散列表</strong></p>
<ul>
<li>实现散列表的几种方法</li>
<li>分析比较几种方法</li>
<li>介绍散列的多种应用</li>
<li>比较散列表与二叉查找树</li>
</ul>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>基本思想：将每个键(Key)映射到从[0, TableSize)这个范围中的某个数，并且将其放到适当的单元中，这个映射就称为<strong>散列函数</strong>。<br>问题：选择一个函数，决定当两个键散列到同一个值的时候（称为<strong>冲突(collision)</strong>应该做什么以及如何确定散列表的大小。<br><em>注：一般使表的大小为素数，有助于避免部分冲突问题</em></p>
<h3 id="装填因子-load-factor"><a href="#装填因子-load-factor" class="headerlink" title="装填因子(load factor)"></a>装填因子(load factor)</h3><p>定义散列表的装填因子 λ 为散列表中的元素个数与散列表大小的比值。</p>
<h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>将散列到同一个值的所有元素保留到一个链表中。<br>一般法则：使 λ ≈ 1，控制链表的长度，若 λ &gt; 1 则通过再散列扩充</p>
<h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>不用链表存储，实现分配较大空间，称为<strong>探测散列表</strong><br>hi(x) = (hash(x) + f(i)) mod TableSize, f(0) = 0.<br>一般 λ &gt; 0.5 就要再散列</p>
<ul>
<li>线性探测 f(i) = i</li>
<li>平方探测 f(i) = i^2</li>
<li>双散列 f(i) = i * hash2(x), hash2(x) = R - (x mod R) 这样的函数会起作用，其中R为小于TableSize的素数</li>
</ul>
<h2 id="再散列-rehash"><a href="#再散列-rehash" class="headerlink" title="再散列(rehash)"></a>再散列(rehash)</h2><ol>
<li>只要表到一半就再散列</li>
<li>只有插入失败时才再散列</li>
<li>途中策略：当表到达某一个装填因子时进行再散列（最优）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;散列表（hash table）的实现通常称为散列（hashing），指用于以O(1)时间执行插入、删除和查找的技术，但不支持需要排序信息的树操作，比如findMin、findMax以及在线性时间内按顺序打印整个表都不支持&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（四）：树</title>
    <link href="https://i-square.github.io/post/DS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91/"/>
    <id>https://i-square.github.io/post/DS学习笔记-树/</id>
    <published>2017-03-31T14:05:29.000Z</published>
    <updated>2017-04-19T08:46:42.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>了解树是如何用于实现文件系统的</li>
<li>了解树如何用来计算算术表达式的值</li>
<li>了解如何用树实现O(logN)时间进行搜素</li>
<li>讨论并使用set和map</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul>
<li>前序：先处理自己后处理左右儿子</li>
<li>中序：先处理左儿子再处理自己再处理右儿子</li>
<li>后序：先处理左右儿子再处理自己</li>
</ul>
<h2 id="二叉查找树（平均深度O-logN-）"><a href="#二叉查找树（平均深度O-logN-）" class="headerlink" title="二叉查找树（平均深度O(logN)）"></a>二叉查找树（平均深度O(logN)）</h2><p>性质：对于树中的每个节点X，左子树中所有项的值小于X中的项，右子树中所有项的值大于X中的项<br>缺点：不能动态调整，若输入为已排序序列则构造出最坏情况下的斜树</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul>
<li>带有<strong>平衡条件</strong>的二叉查找树</li>
<li>一棵AVL树是每个节点的左子树和右子树的高度最多相差1的二叉查找树（空树高度定义为-1）</li>
<li>插入新节点可能破坏AVL树的平衡，需要通过<strong>旋转</strong>解决</li>
</ul>
<p>把需要平衡的节点叫α  </p>
<ol>
<li>对α的左儿子的左子树进行一次插入</li>
<li>对α的左儿子的右子树进行一次插入</li>
<li>对α的右儿子的左子树进行一次插入</li>
<li>对α的右儿子的右子树进行一次插入</li>
</ol>
<p>1和4（左左，右右）发生在外边，进行一次<strong>单旋转</strong>即可，2和3（左右，右左）则发生在内部，需要通过<strong>双旋转</strong>调整</p>
<h2 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h2><p>节点可以达到任意深度，每次访问某节点后把该节点调整为根节点，任意连续M次操作花费O(MlogN)时间</p>
<h2 id="B树（平衡M路树）"><a href="#B树（平衡M路树）" class="headerlink" title="B树（平衡M路树）"></a>B树（平衡M路树）</h2><p>M=3时：2-3树，实现平衡查找树的另一种方法</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>通过插入元素构造查找树，然后执行中序遍历，可以得到排序后的元素。<br>这是一种O(NlogN)的排序算法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;了解树是如何用于实现文件系统的&lt;/li&gt;
&lt;li&gt;了解树如何用来计算算术表达式的值&lt;/li&gt;
&lt;li&gt;了解如何用树实现O(log
    
    </summary>
    
      <category term="学习笔记" scheme="https://i-square.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://i-square.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MathType6.9b不兼容Office2016的解决办法</title>
    <link href="https://i-square.github.io/post/MathType6-9b%E4%B8%8D%E5%85%BC%E5%AE%B9Office2016%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://i-square.github.io/post/MathType6-9b不兼容Office2016的解决办法/</id>
    <published>2017-03-29T10:37:43.000Z</published>
    <updated>2017-03-29T10:55:39.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>安装MathType6.9b后打开Word2016，发现菜单栏里并没有集成MathType，想办法解决以后，菜单栏上已经集成了MathType，但是仍然不能用，每次打开Word都会弹框提示Mathpage.wll未找到，无奈又去网上找寻了解决办法，在这里记录一下，就当云笔记了。</p>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="Office2016支持"><a href="#Office2016支持" class="headerlink" title="Office2016支持"></a>Office2016支持</h3><p>Office2016需要在MathType根目录下添加文件MPlugin.dll，一般在安装文件夹里</p>
<h3 id="Mathpage-wll未找到问题"><a href="#Mathpage-wll未找到问题" class="headerlink" title="Mathpage.wll未找到问题"></a>Mathpage.wll未找到问题</h3><p>通过以下方法解决(以Office2016为例)：</p>
<ol>
<li>依次打开<code>Word→文件→选项→信任中心→信任中心设置→受信任位置→添加新位置</code><br>添加 <code>C:\Program Files\Microsoft Office\Office16\STARTUP</code>，然后关闭Word</li>
<li>在mathtype安装目录下找到以下2个文件(以64位系统为例):  <ul>
<li><code>C:\Program Files (x86)\MathType\MathPage\64\MathPage.wll</code></li>
<li><code>C:\Program Files (x86)\MathType\Office Support\64\MathType Commands 6 For Word 2016.dotm</code></li>
</ul>
</li>
<li>将两个文件分别拷贝到对应的文件夹中:  <ul>
<li>将<code>MathType Commands 6 For Word 2016.dotm</code> 拷贝到 <code>C:\Program Files\Microsoft Office\Office16\STARTUP</code></li>
<li>将 <code>MathPage.wll</code> 拷贝到 <code>C:\Program Files\Microsoft Office\Office16</code></li>
</ul>
</li>
<li>重新打开Word你会发现一切都OK了!</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;安装MathType6.9b后打开Word2016，发现菜单栏里并没有集成MathType，想办法解决以后，菜单栏上已经集成了MathType，但是仍然不能用，每次打开Word都会弹框提示Mathpage.wll未找到，无奈又去网上找寻了解决办法，在这里记录一下，就当云笔记了。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://i-square.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Office" scheme="https://i-square.github.io/tags/Office/"/>
    
      <category term="MathType" scheme="https://i-square.github.io/tags/MathType/"/>
    
  </entry>
  
</feed>
