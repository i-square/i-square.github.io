<!doctype html><html lang=zh-hans dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。
假设输入数据支持&amp;quot;&amp;lt;&amp;ldquo;和&amp;rdquo;&amp;gt;&amp;ldquo;操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。
内容 对内部排序的考查将指出：
存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序 希尔排序编程简单，以o(N^2)运行，在实践中很有效 还有一些稍微复杂的O(NlogN)算法 任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较 插入排序 (insertion sort) 插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。
分析 O(N^2) 精确界，反序输入可达。
若已排序输入，则O(N)
平均情形Θ(N^2)
一些简单排序算法的下界 定理1 N个互异元素的数组的平均逆序数是N(N-1)/4
定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间
对冒泡排序、选择排序、插入排序都有效
定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。
希尔排序 (shell sort) 发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。
它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做缩减增量排序(diminishing increment sort)
分析 使用希尔增量的最坏情形Θ(N^2)
Hibbard增量：1，3，7，…… ，2^k - 1
使用Hibbard增量的最坏情形Θ(N^(3/2))
Sedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))
希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。
堆排序 (heap sort) 如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序
由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)
使用了附加数组，存储需求增加了一倍
避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆
以O(N)建立max堆 交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax 循环执行步骤2，N-1次 分析 在最坏情形下堆排序最多使用2NlogN-O(N)次比较
堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少
定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN)
可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明
归并排序 (merge sort) 以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例
算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的
算法 基准情形：N=1时，结果是显然的
否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并
该算法是经典的分治策略，它将问题分(divide)成一些小问题然后递归求解，而治(conquering)的阶段则是将分的阶段解得的各答案合并在一起
分析 分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。
假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有
T(1) = 1"><title>数据结构学习笔记（七）：排序</title><link rel=canonical href=https://i-square.github.io/p/Data-structure-study-notes-7-sorting/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="数据结构学习笔记（七）：排序"><meta property="og:description" content="在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。
假设输入数据支持&amp;quot;&amp;lt;&amp;ldquo;和&amp;rdquo;&amp;gt;&amp;ldquo;操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。
内容 对内部排序的考查将指出：
存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序 希尔排序编程简单，以o(N^2)运行，在实践中很有效 还有一些稍微复杂的O(NlogN)算法 任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较 插入排序 (insertion sort) 插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。
分析 O(N^2) 精确界，反序输入可达。
若已排序输入，则O(N)
平均情形Θ(N^2)
一些简单排序算法的下界 定理1 N个互异元素的数组的平均逆序数是N(N-1)/4
定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间
对冒泡排序、选择排序、插入排序都有效
定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。
希尔排序 (shell sort) 发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。
它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做缩减增量排序(diminishing increment sort)
分析 使用希尔增量的最坏情形Θ(N^2)
Hibbard增量：1，3，7，…… ，2^k - 1
使用Hibbard增量的最坏情形Θ(N^(3/2))
Sedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))
希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。
堆排序 (heap sort) 如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序
由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)
使用了附加数组，存储需求增加了一倍
避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆
以O(N)建立max堆 交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax 循环执行步骤2，N-1次 分析 在最坏情形下堆排序最多使用2NlogN-O(N)次比较
堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少
定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN)
可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明
归并排序 (merge sort) 以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例
算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的
算法 基准情形：N=1时，结果是显然的
否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并
该算法是经典的分治策略，它将问题分(divide)成一些小问题然后递归求解，而治(conquering)的阶段则是将分的阶段解得的各答案合并在一起
分析 分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。
假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有
T(1) = 1"><meta property="og:url" content="https://i-square.github.io/p/Data-structure-study-notes-7-sorting/"><meta property="og:site_name" content="平方君的后花园"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="排序"><meta property="article:published_time" content="2017-04-23T22:01:12+00:00"><meta property="article:modified_time" content="2017-04-23T22:01:12+00:00"><meta name=twitter:title content="数据结构学习笔记（七）：排序"><meta name=twitter:description content="在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。
假设输入数据支持&amp;quot;&amp;lt;&amp;ldquo;和&amp;rdquo;&amp;gt;&amp;ldquo;操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。
内容 对内部排序的考查将指出：
存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序 希尔排序编程简单，以o(N^2)运行，在实践中很有效 还有一些稍微复杂的O(NlogN)算法 任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较 插入排序 (insertion sort) 插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。
分析 O(N^2) 精确界，反序输入可达。
若已排序输入，则O(N)
平均情形Θ(N^2)
一些简单排序算法的下界 定理1 N个互异元素的数组的平均逆序数是N(N-1)/4
定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间
对冒泡排序、选择排序、插入排序都有效
定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。
希尔排序 (shell sort) 发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。
它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做缩减增量排序(diminishing increment sort)
分析 使用希尔增量的最坏情形Θ(N^2)
Hibbard增量：1，3，7，…… ，2^k - 1
使用Hibbard增量的最坏情形Θ(N^(3/2))
Sedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))
希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。
堆排序 (heap sort) 如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序
由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)
使用了附加数组，存储需求增加了一倍
避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆
以O(N)建立max堆 交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax 循环执行步骤2，N-1次 分析 在最坏情形下堆排序最多使用2NlogN-O(N)次比较
堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少
定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN)
可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明
归并排序 (merge sort) 以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例
算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的
算法 基准情形：N=1时，结果是显然的
否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并
该算法是经典的分治策略，它将问题分(divide)成一些小问题然后递归求解，而治(conquering)的阶段则是将分的阶段解得的各答案合并在一起
分析 分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。
假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有
T(1) = 1"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu5ad7b3c288b7ec9c6597012c8b723e22_6153_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>💤</span></figure><div class=site-meta><h1 class=site-name><a href=/>平方君的后花园</a></h1><h2 class=site-description>人生苦短，及时行乐。</h2></div></header><ol class=social-menu><li><a href=mailto:i_square@qq.com target=_blank title=E-Mail rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 5m0 2a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=https://github.com/i-square target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页 | Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档 | Archives</span></a></li><li><a href=/categories/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg><span>分类 | Categories</span></a></li><li><a href=/tags/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg><span>标签 | Tags</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索 | Search</span></a></li><li><a href=/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>链接 | Links</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于 | About</span></a></li><li><a href=/love.html target=_blank><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-heart" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19.5 12.572 12 20l-7.5-7.428A5 5 0 1112 6.006a5 5 0 117.5 6.572"/></svg><span>Love Story</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://i-square.github.io/ selected>中文</option><option value=https://i-square.github.io/en/>English</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#内容>内容</a></li><li><a href=#插入排序-insertion-sort>插入排序 (insertion sort)</a><ol><li><a href=#分析>分析</a></li></ol></li><li><a href=#一些简单排序算法的下界>一些简单排序算法的下界</a></li><li><a href=#希尔排序-shell-sort>希尔排序 (shell sort)</a><ol><li><a href=#分析-1>分析</a></li></ol></li><li><a href=#堆排序-heap-sort>堆排序 (heap sort)</a><ol><li><a href=#分析-2>分析</a></li></ol></li><li><a href=#归并排序-merge-sort>归并排序 (merge sort)</a><ol><li><a href=#算法>算法</a></li><li><a href=#分析-3>分析</a></li></ol></li><li><a href=#快速排序-quick-sort>快速排序 (quick sort)</a><ol><li><a href=#选取枢纽元>选取枢纽元</a></li><li><a href=#分割策略>分割策略</a></li><li><a href=#小数组>小数组</a></li><li><a href=#分析-4>分析</a></li></ol></li><li><a href=#快速选择-quick-select>快速选择 (quick select)</a><ol><li><a href=#分析-5>分析</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a>
<a href=/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/Data-structure-study-notes-7-sorting/>数据结构学习笔记（七）：排序</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Apr 23, 2017</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 1 分钟</time></div></footer></div></header><section class=article-content><p>在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。<br>假设输入数据支持"&lt;&ldquo;和&rdquo;>&ldquo;操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。</p><h2 id=内容>内容</h2><p>对内部排序的考查将指出：</p><ul><li>存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序</li><li>希尔排序编程简单，以o(N^2)运行，在实践中很有效</li><li>还有一些稍微复杂的O(NlogN)算法</li><li>任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较</li></ul><h2 id=插入排序-insertion-sort>插入排序 (insertion sort)</h2><p>插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。</p><h3 id=分析>分析</h3><p>O(N^2) 精确界，反序输入可达。<br>若已排序输入，则O(N)<br>平均情形Θ(N^2)</p><h2 id=一些简单排序算法的下界>一些简单排序算法的下界</h2><p>定理1 N个互异元素的数组的平均逆序数是N(N-1)/4<br>定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间<br>对冒泡排序、选择排序、插入排序都有效<br>定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。</p><h2 id=希尔排序-shell-sort>希尔排序 (shell sort)</h2><p>发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。</p><p>它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做<strong>缩减增量排序</strong>(diminishing increment sort)</p><h3 id=分析-1>分析</h3><p>使用希尔增量的最坏情形Θ(N^2)<br>Hibbard增量：1，3，7，…… ，2^k - 1<br>使用Hibbard增量的最坏情形Θ(N^(3/2))<br>Sedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))<br>希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。</p><h2 id=堆排序-heap-sort>堆排序 (heap sort)</h2><p>如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序</p><p>由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)<br>使用了附加数组，存储需求增加了一倍</p><p>避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆</p><ol><li>以O(N)建立max堆</li><li>交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax</li><li>循环执行步骤2，N-1次</li></ol><h3 id=分析-2>分析</h3><p>在最坏情形下堆排序最多使用2NlogN-O(N)次比较<br>堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少</p><p>定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN)</p><p>可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明</p><h2 id=归并排序-merge-sort>归并排序 (merge sort)</h2><p>以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例</p><p>算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的</p><h3 id=算法>算法</h3><p>基准情形：N=1时，结果是显然的<br>否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并</p><p>该算法是经典的<strong>分治</strong>策略，它将问题<strong>分</strong>(divide)成一些小问题然后递归求解，而<strong>治</strong>(conquering)的阶段则是将分的阶段解得的各答案合并在一起</p><h3 id=分析-3>分析</h3><p>分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。<br>假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有<br>T(1) = 1<br>T(N) = 2T(N/2) + N<br>求解得 T(N) = NlogN + N = O(NlogN)</p><p>利弊：在java中比较耗时多于移动，因此在java中归并排序是一般目的排序的最佳选择；但在C++中，比较耗时少而复制对象代价很大，因此实践中不常用</p><h2 id=快速排序-quick-sort>快速排序 (quick sort)</h2><p>快排是实践中最快的已知排序算法，平均运行时间是O(NlogN)，最坏情形是O(N^2)，但稍作努力就可避免。<br>通过将堆排序与快速排序结合，可以在堆排序O(NlogN)最坏运行时间下，得到几乎所有输入的最快运行时间。</p><p>快排也是分治的递归算法，排序数组S步骤如下：</p><ol><li>若S中元素数是0或1，则返回</li><li>取S中任一元素v，称之为<strong>枢纽元</strong>(pivot)</li><li>将S-{v}（S中其余元素）<strong>划分</strong>成两个不相交的集合：S1={x∈S-{v}|x≤v}和S2={x∈S-{v}|x≥v}</li><li>返回{quickSort(S1),后跟v,继而quickSort(S2)}</li></ol><p>第三步中划分的标准不是唯一的，因此这就成了设计决策。一部分好的实现方法是将这种情形尽可能有效地处理。直观地看，我们希望枢纽元能将元素对半分，一半在S1，另一半在S2。</p><h3 id=选取枢纽元>选取枢纽元</h3><ol><li>一种典型的错误是将第一个元素选作枢纽元。若输入随机，那么这是可以接受的，但实际情况有很多预排序的序列，这样的分割是劣质的。类似的还有选取前2个元素的大者，这是一样的，不要使用。</li><li>一种安全的做法是随机选取枢纽元，但这取决于随机数生成器的质量，而且声称随机数的代价一般也是很昂贵的。</li><li>三数中值分割法<br>一组N个数的中值是第上取整(N/2)个最大的数。枢纽元的最好选择是数组的中值，但算出中值代价太高。一般的做法是选取左端、右端和中心位置上的三个元素的中值作为枢纽元。显然该方法消除了预排序输入的不好情形，并且减少了约14%的比较次数。</li></ol><h3 id=分割策略>分割策略</h3><ol><li>将枢纽元与最后的元素交换</li><li>i从第一个元素开始，j从倒数第二个元素开始</li><li>当i在j左边时，右移i，移过小于枢纽元的元素，j左移，移过大于枢纽元的元素，i,j都停止时交换两个元素，直到i,j交错</li><li>将枢纽元与i所指向的元素交换</li></ol><p>如何处理等于枢纽元的元素？<br>若等于，则停止移动</p><h3 id=小数组>小数组</h3><p>对于很小的数组（N≤20），快速排序不如插入排序，而且，因为快排是递归的，这样的情形经常发生。通常的解决办法是，对于小数组使用插入排序。一种好的截止范围(cutoff range)是N=10</p><h3 id=分析-4>分析</h3><p>最坏情形：O(N^2)
最佳情形：O(NlogN)
平均情形：O(NlogN)</p><h2 id=快速选择-quick-select>快速选择 (quick select)</h2><p>修改快速排序以解决选择问题，即找第k个最大（小）元。</p><p>前3步和快速排序一样<br>第4步</p><ul><li>若k≤S1，那么k必然在S1中，返回quickSelect(S1, K)</li><li>若k = 1 + |S1|，那么枢纽元就是第k个最小元</li><li>否则，第k个最小元就在S2中，它是S2中的第（k-|S1|-1）个最小元，返回quickSelect(S2, k-|S1|-1)</li></ul><h3 id=分析-5>分析</h3><p>与快排相比，快速选择只进行了一次递归调用而不是两次</p><p>最坏情形：O(N^2)，当S1和S2一个是空时
平均情形：O(N)</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E6%8E%92%E5%BA%8F/>排序</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/Data-structure-study-notes-8-Disjoint-set-classes/><div class=article-details><h2 class=article-title>数据结构学习笔记（八）：不相交集类</h2></div></a></article><article><a href=/p/Data-structure-study-notes-6-priority-queue-heap/><div class=article-details><h2 class=article-title>数据结构学习笔记（六）：优先队列（堆）</h2></div></a></article><article><a href=/p/Data-structure-study-notes-5-hash/><div class=article-details><h2 class=article-title>数据结构学习笔记（五）：散列</h2></div></a></article><article><a href=/p/Data-structure-study-notes-4-tree/><div class=article-details><h2 class=article-title>数据结构学习笔记（四）：树</h2></div></a></article><article><a href=/p/Data-structure-study-notes-3-tables-stacks-and-queues/><div class=article-details><h2 class=article-title>数据结构学习笔记（三）：表、栈和队列</h2></div></a></article></div></div></aside><div id=cusdis_thread data-host=https://cusdis.com data-app-id=0d2babe1-c058-48ca-a64b-c5afdfa1cb19 data-page-id=15b5be53778a53c04e7350ee3b6e8e04 data-page-url=https://i-square.github.io/p/Data-structure-study-notes-7-sorting/ data-page-title=数据结构学习笔记（七）：排序></div><script async defer src=https://cusdis.com/js/cusdis.es.js></script>
<script>function setCusdisTheme(e){let t=document.querySelector("#cusdis_thread iframe");t&&window.CUSDIS.setTheme(e)}window.addEventListener("onColorSchemeChange",e=>{setCusdisTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2023 平方君的后花园</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>