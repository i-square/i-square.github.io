[{"title":"数据结构学习笔记（七）：排序","date":"2017-04-23T14:01:12.000Z","path":"post/DS学习笔记-排序/","text":"在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。假设输入数据支持”&lt;”和”&gt;”操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。 内容对内部排序的考查将指出： 存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序 希尔排序编程简单，以o(N^2)运行，在实践中很有效 还有一些稍微复杂的O(NlogN)算法 任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较 插入排序 (insertion sort)插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。 分析O(N^2) 精确界，反序输入可达。若已排序输入，则O(N)平均情形Θ(N^2) 一些简单排序算法的下界定理1 N个互异元素的数组的平均逆序数是N(N-1)/4定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间对冒泡排序、选择排序、插入排序都有效定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。 希尔排序 (shell sort)发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。 它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做缩减增量排序(diminishing increment sort) 分析使用希尔增量的最坏情形Θ(N^2)Hibbard增量：1，3，7，…… ，2^k - 1使用Hibbard增量的最坏情形Θ(N^(3/2))Sedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。 堆排序 (heap sort)如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序 由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)使用了附加数组，存储需求增加了一倍 避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆 以O(N)建立max堆 交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax 循环执行步骤2，N-1次 分析在最坏情形下堆排序最多使用2NlogN-O(N)次比较堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少 定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN) 可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明 归并排序 (merge sort)以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例 算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的 算法基准情形：N=1时，结果是显然的否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并 该算法是经典的分治策略，它将问题分(divide)成一些小问题然后递归求解，而治(conquering)的阶段则是将分的阶段解得的各答案合并在一起 分析分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有T(1) = 1T(N) = 2T(N/2) + N求解得 T(N) = NlogN + N = O(NlogN) 利弊：在java中比较耗时多于移动，因此在java中归并排序是一般目的排序的最佳选择；但在C++中，比较耗时少而复制对象代价很大，因此实践中不常用 快速排序 (quick sort)快排是实践中最快的已知排序算法，平均运行时间是O(NlogN)，最坏情形是O(N^2)，但稍作努力就可避免。通过将堆排序与快速排序结合，可以在堆排序O(NlogN)最坏运行时间下，得到几乎所有输入的最快运行时间。 快排也是分治的递归算法，排序数组S步骤如下： 若S中元素数是0或1，则返回 取S中任一元素v，称之为枢纽元(pivot) 将S-{v}（S中其余元素）划分成两个不相交的集合：S1={x∈S-{v}|x≤v}和S2={x∈S-{v}|x≥v} 返回{quickSort(S1),后跟v,继而quickSort(S2)} 第三步中划分的标准不是唯一的，因此这就成了设计决策。一部分好的实现方法是将这种情形尽可能有效地处理。直观地看，我们希望枢纽元能将元素对半分，一半在S1，另一半在S2。 选取枢纽元 一种典型的错误是将第一个元素选作枢纽元。若输入随机，那么这是可以接受的，但实际情况有很多预排序的序列，这样的分割是劣质的。类似的还有选取前2个元素的大者，这是一样的，不要使用。 一种安全的做法是随机选取枢纽元，但这取决于随机数生成器的质量，而且声称随机数的代价一般也是很昂贵的。 三数中值分割法一组N个数的中值是第上取整(N/2)个最大的数。枢纽元的最好选择是数组的中值，但算出中值代价太高。一般的做法是选取左端、右端和中心位置上的三个元素的中值作为枢纽元。显然该方法消除了预排序输入的不好情形，并且减少了约14%的比较次数。 分割策略 将枢纽元与最后的元素交换 i从第一个元素开始，j从倒数第二个元素开始 当i在j左边时，右移i，移过小于枢纽元的元素，j左移，移过大于枢纽元的元素，i,j都停止时交换两个元素，直到i,j交错 将枢纽元与i所指向的元素交换 如何处理等于枢纽元的元素？若等于，则停止移动 小数组对于很小的数组（N≤20），快速排序不如插入排序，而且，因为快排是递归的，这样的情形经常发生。通常的解决办法是，对于小数组使用插入排序。一种好的截止范围(cutoff range)是N=10 分析最坏情形：O(N^2)最佳情形：O(NlogN)平均情形：O(NlogN) 快速选择 (quick select)修改快速排序以解决选择问题，即找第k个最大（小）元。 前3步和快速排序一样第4步 若k≤S1，那么k必然在S1中，返回quickSelect(S1, K) 若k = 1 + |S1|，那么枢纽元就是第k个最小元 否则，第k个最小元就在S2中，它是S2中的第（k-|S1|-1）个最小元，返回quickSelect(S2, k-|S1|-1) 分析与快排相比，快速选择只进行了一次递归调用而不是两次 最坏情形：O(N^2)，当S1和S2一个是空时平均情形：O(N)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"数据结构学习笔记（六）：优先队列（堆）","date":"2017-04-20T14:27:15.000Z","path":"post/DS学习笔记-优先队列（堆）/","text":"本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用作者评价：这类数据结构属于计算机科学中最雅致的一种 内容 优先队列ADT的高效实现 优先队列的使用 优先队列的高级实现 二叉堆 (binary heap)插入删除最坏O(logN)，实际上插入花费常数平均时间，若无删除干扰，该结构将以线性时间建立一个具有N项的优先队列。与二叉查找树一样，堆具有两个性质，堆的操作必须满足所有性质才能终止。 结构性质堆是一棵完全二叉树（三角形缺右下角），特例是满二叉树（三角形），最底层元素必须从左往右填入，如有空缺则不是完全二叉树一棵高为h的完全二叉树有[2^h , 2^(h+1) - 1]个节点，这意味着完全二叉树的高是 下取整(logN)，显然它是O(logN)的因为此规律，所以堆可以用数组表示而不用链表，对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的(2i+1)上，它的父亲在位置 下取整(i/2) 上 堆序性质在堆中，除根节点以外，每一个节点的值都大于（或等于）它的父节点的值根据堆序性质，最小值总在根结点，因此可以以O(1)时间做findMin相应地，通过改变堆序性质，也可以建立一个max堆，以O(1)时间做findMax 插入（上滤策略）为了插入新元素X，在堆的下一个可用位置（为了满足结构性质）创建一个空穴，若X放入空穴仍满足堆序性质，则插入完成，否则交换空穴和其父节点，直到X被放入并满足堆序性质为止 删除（下滤策略）找出最小元很容易，难的是删除它。当删除一个最小元时，堆中最后一个元素X必须移动到该堆的某个地方。策略是在根节点建立一个空穴，然后将两个儿子中的较小者移入空穴，重复该步骤直到X可以被放入空穴中。代码中则是用X直接替换根结点的值，然后下滤。 注意在堆的实现中经常出现的错误是，当堆中存在偶数个元素时，将出现一个节点只有一个儿子的情况。因此我们必须以节点不总有两个儿子为前提，这需要额外的测试。 应用选择问题输入N个元素及整数k，找出第k个最大的元素，极端情况是k=上取整(N/2)，此时实际上是找中位数，以下两个算法都能在找中位数的情况下以O(NlogN)时间运行 A 将N个元素读入数组，对数组应用buildHeap，再执行k次deleteMin，最后根节点上的就是第k个最小值，构造一个最大堆就可以找到第k个最大值 B 用buildHeap将前k个元素构造成一个最大堆，若下一个元素大于堆里的最小值，则删除最小值，插入新元素，最终的最小值就是所求的第k个最大值 d堆类似B树，深度变浅，每个节点有d个儿子 左式堆 (leftist heap)左式堆也是二叉树，但它不是理想平衡的，事实上是趋于非常不平衡 定义任一节点X的零路径长(null path length)npl(X)为从X到一个不具有两个儿子的节点的最短路径长因此，具有0个或1个儿子的节点npl为0，而npl(NULL)=-1注意，任一节点的npl比它儿子节点的npl的最小值多1 左式堆性质对于堆中的每一个节点X，左儿子的npl至少与右儿子的npl一样大这个性质导致树向左增加深度，沿左式堆右侧的右路径是堆中最短的路径定理：在右路径上有r个节点的左式堆必然至少有2^r -1个节点 对左式堆的基本操作是合并。插入可以看成是合并一个单节点堆，删除即是删掉根结点，然后合并左右子树。 斜堆 (skew heap)斜堆是左式堆的自调节形式，具有堆序，但不存在结构限制。斜堆不需要存储npl，每次合并无条件交换左右儿子。 二项队列 (binomial queue)以最坏O(logN)支持插入、合并、deleteMin，插入操作平均花费常数时间 实质是由二项树(binomial tree)构成的森林(forest)。每一个高度上最多存在一棵二项树。高度为k的二项树Bk是通过将一棵二项树B(k-1)附接到另一棵二项树B(k-1)的根上构成的。高度为k的二项树有2^k个节点，在深度d处的节点数是二项系数C(d,k) 如果把堆序性质施加到二项树上并允许任意高度上最多一棵二项树，则可以用二项树的集合唯一地表示任意大小的优先队列。如大小为13的优先队列可以用B3,B2,B0表示，可以写成1101，同时也是13的二进制形式。 操作基本操作仍然是合并，思想是从小到大合并相同高度的二项树插入是特殊情况下的合并deleteMin将原二项队列一分为二，再合并 编程需要注意进位的实现","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"C盘根目录下的两个sys文件说明","date":"2017-04-19T08:24:22.000Z","path":"post/C盘根目录下的两个sys文件说明/","text":"前言实验室里有一台高配工作站，内存有512GB，用一块256GB的SSD安装Win7 x64操作系统以后，硬盘空间只剩下几十MB了，查看C盘下的文件之后，发现有两个隐藏的系统文件占用了200GB+的空间，于是马上查了它们的来头。 pagefile.syspagefile.sys是系统安装过程中创建的虚拟内存页面文件。这个文件的大小是自己系统虚拟内存设置的最小值的大小。假如虚拟内存的设置为800MB－1600MB 那么你在自己的设定驱动盘下面就可看到大小为800MB的pagefile.sys文件。 优化方法通常自己可以在我的电脑右键属性–&gt;高级–&gt;性能–&gt;高级–&gt;虚拟内存中将所有盘的虚拟内存设置为无分页文件，并选择设置后重启系统，就可以删除页面文件pagefile.sys。 hiberfil.sys这个文件是系统的休眠功能所占用的硬盘空间的文件（Windows默认休眠功能是处于打开状态的），电脑处于休眠状态时，内存中的所有内容将保存到硬盘，并且电脑会被关闭。电脑在返回打开状态之后，关闭电脑时打开的所有程序和文档将全都还原到桌面。也就是说，当你让电脑进入休眠状态时，Windows在关闭系统前将所有的内存内容写入hiberfil.sys文件，当你重新打开电脑，操作系统使用hiberfil.sys把所有信息放回内存，电脑恢复到关闭前的状态。然而，只要休眠功能开启，Windows就会在硬盘上留下hiberfil.sys文件，即使你从来不休眠。 优化方法以管理员身份运行CMD，然后输入命令powercfg -h off，回车后立即生效，hiberfil.sys文件已经不见了。","tags":[{"name":"Windows","slug":"Windows","permalink":"https://i-square.github.io/tags/Windows/"}]},{"title":"数据结构学习笔记（五）：散列","date":"2017-04-07T14:48:51.000Z","path":"post/DS学习笔记-散列/","text":"散列表（hash table）的实现通常称为散列（hashing），指用于以O(1)时间执行插入、删除和查找的技术，但不支持需要排序信息的树操作，比如findMin、findMax以及在线性时间内按顺序打印整个表都不支持 内容中心数据结构是散列表 实现散列表的几种方法 分析比较几种方法 介绍散列的多种应用 比较散列表与二叉查找树 散列函数基本思想：将每个键(Key)映射到从[0, TableSize)这个范围中的某个数，并且将其放到适当的单元中，这个映射就称为散列函数。问题：选择一个函数，决定当两个键散列到同一个值的时候（称为冲突(collision)应该做什么以及如何确定散列表的大小。注：一般使表的大小为素数，有助于避免部分冲突问题 装填因子(load factor)定义散列表的装填因子 λ 为散列表中的元素个数与散列表大小的比值。 分离链接法将散列到同一个值的所有元素保留到一个链表中。一般法则：使 λ ≈ 1，控制链表的长度，若 λ &gt; 1 则通过再散列扩充 开放定址法不用链表存储，实现分配较大空间，称为探测散列表hi(x) = (hash(x) + f(i)) mod TableSize, f(0) = 0.一般 λ &gt; 0.5 就要再散列 线性探测 f(i) = i 平方探测 f(i) = i^2 双散列 f(i) = i * hash2(x), hash2(x) = R - (x mod R) 这样的函数会起作用，其中R为小于TableSize的素数 再散列(rehash) 只要表到一半就再散列 只有插入失败时才再散列 途中策略：当表到达某一个装填因子时进行再散列（最优）","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"数据结构学习笔记（四）：树","date":"2017-03-31T14:05:29.000Z","path":"post/DS学习笔记-树/","text":"内容 了解树是如何用于实现文件系统的 了解树如何用来计算算术表达式的值 了解如何用树实现O(logN)时间进行搜素 讨论并使用set和map 二叉树的遍历 前序：先处理自己后处理左右儿子 中序：先处理左儿子再处理自己再处理右儿子 后序：先处理左右儿子再处理自己 二叉查找树（平均深度O(logN)）性质：对于树中的每个节点X，左子树中所有项的值小于X中的项，右子树中所有项的值大于X中的项缺点：不能动态调整，若输入为已排序序列则构造出最坏情况下的斜树 AVL树 带有平衡条件的二叉查找树 一棵AVL树是每个节点的左子树和右子树的高度最多相差1的二叉查找树（空树高度定义为-1） 插入新节点可能破坏AVL树的平衡，需要通过旋转解决 把需要平衡的节点叫α 对α的左儿子的左子树进行一次插入 对α的左儿子的右子树进行一次插入 对α的右儿子的左子树进行一次插入 对α的右儿子的右子树进行一次插入 1和4（左左，右右）发生在外边，进行一次单旋转即可，2和3（左右，右左）则发生在内部，需要通过双旋转调整 伸展树节点可以达到任意深度，每次访问某节点后把该节点调整为根节点，任意连续M次操作花费O(MlogN)时间 B树（平衡M路树）M=3时：2-3树，实现平衡查找树的另一种方法 注意通过插入元素构造查找树，然后执行中序遍历，可以得到排序后的元素。这是一种O(NlogN)的排序算法","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"MathType6.9b不兼容Office2016的解决办法","date":"2017-03-29T10:37:43.000Z","path":"post/MathType6-9b不兼容Office2016的解决办法/","text":"问题安装MathType6.9b后打开Word2016，发现菜单栏里并没有集成MathType，想办法解决以后，菜单栏上已经集成了MathType，但是仍然不能用，每次打开Word都会弹框提示Mathpage.wll未找到，无奈又去网上找寻了解决办法，在这里记录一下，就当云笔记了。 解决办法Office2016支持Office2016需要在MathType根目录下添加文件MPlugin.dll，一般在安装文件夹里 Mathpage.wll未找到问题通过以下方法解决(以Office2016为例)： 依次打开Word→文件→选项→信任中心→信任中心设置→受信任位置→添加新位置添加 C:\\Program Files\\Microsoft Office\\Office16\\STARTUP，然后关闭Word 在mathtype安装目录下找到以下2个文件(以64位系统为例): C:\\Program Files (x86)\\MathType\\MathPage\\64\\MathPage.wll C:\\Program Files (x86)\\MathType\\Office Support\\64\\MathType Commands 6 For Word 2016.dotm 将两个文件分别拷贝到对应的文件夹中: 将MathType Commands 6 For Word 2016.dotm 拷贝到 C:\\Program Files\\Microsoft Office\\Office16\\STARTUP 将 MathPage.wll 拷贝到 C:\\Program Files\\Microsoft Office\\Office16 重新打开Word你会发现一切都OK了!","tags":[{"name":"Office","slug":"Office","permalink":"https://i-square.github.io/tags/Office/"},{"name":"MathType","slug":"MathType","permalink":"https://i-square.github.io/tags/MathType/"}]},{"title":"数据结构学习笔记（三）：表、栈和队列","date":"2017-03-27T07:27:43.000Z","path":"post/DS学习笔记-表、栈和队列/","text":"内容 介绍三种基本的数据结构 介绍抽象数据类型(ADT, abstract data type)的概念 介绍栈ADT及其在实现递归方面的应用 介绍队列ADT及其在操作系统和算法设计中的应用 给出vector和list的重要子集的实现 栈实现栈是一个表，因此任何实现表的方法都能实现栈。 应用 符号平衡 后缀（逆波兰）表达式计算 中缀到后缀的转换 函数调用（代码实现了一个简单的计算器，应保证输入合法） 总结快慢指针ex 3.34 提示：判断一个链表是否有环，只使用O(1)的额外空间，使用两个迭代器p,q p每次递增1，q每次递增2，若q到了末尾则没环，否则pq必定在环中间相遇 也可用于快速找出单链表的中间节点","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"Office2016中右键无法打开Visio图像的解决办法","date":"2017-03-26T07:21:56.000Z","path":"post/Office2016中右键无法打开Visio图像的解决办法/","text":"问题在Office2016中，右键Visio图像，只有“转换”功能，而不再提供之前早期Office中提供的“打开”和“编辑”功能，那么，如何能够在Office2016中打开visio图像呢？ 解决办法在Visio图上使用 ALT + 双击鼠标左键 即可在Visio中打开直接双击Visio图像则是和之前版本一样，在当前Office窗口中打开Visio图。","tags":[{"name":"Office","slug":"Office","permalink":"https://i-square.github.io/tags/Office/"},{"name":"Visio","slug":"Visio","permalink":"https://i-square.github.io/tags/Visio/"}]},{"title":"数据结构学习笔记（二）：算法分析","date":"2017-03-25T14:48:53.000Z","path":"post/DS学习笔记-算法分析/","text":"内容 主要内容是复杂度分析 大O标记 计算大O时的一般法则 对数规律的一般法则如果一个算法用常数时间（O(1)）将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。 例子 二分搜索提供了O(logN)的查找算法 最大公因数的欧几里得算法也是O(logN)的 幂运算的递归算法","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"数据结构学习笔记（一）：引论","date":"2017-03-24T06:22:23.000Z","path":"post/DS学习笔记-引论/","text":"内容 介绍基本数学知识 简要复习递归 介绍用到的C++知识 递归的四条基本法则 基准情形。必须总有某些基准情形不用递归就能求解。 不断推进。对于那些需要递归求解的情形，递归调用必须总能够朝着基准情形的方向推进。 设计法则。假设所有的递归调用都能运行。 合成效益法则。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"数据结构学习笔记（零）：开始","date":"2017-03-23T03:23:54.000Z","path":"post/DS学习笔记-开始/","text":"前言为了准备今年后半年到来的秋招，我决定开始学习数据结构，为后面的学习打基础，采用的教材是weiss的《数据结构与算法分析C++描述》，计划实现书上上的示例代码以及力所能及的课后习题。 在Github上同步源码，项目地址：https://github.com/i-square/Data-Structure 学习环境 Windows 10 &amp; 8.1 Visual Studio 2015 with update 3 C++ (部分C++11语法)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://i-square.github.io/tags/数据结构/"}]},{"title":"增强VPS安全性的常用方法","date":"2017-03-06T01:24:30.000Z","path":"post/增强VPS安全性的常用方法/","text":"前言因为上一篇文章中提到的目的，我入手了DO的VPS，由于刚刚接触VPS，对于VPS的安全性并没有什么概念，所以我直接使用一个汉化版PuTTY客户端，以root账户在22端口登录的，刚开始登录几次都没出现什么状况，然而隔天登录的时候就出现了类似以下的提示，这才让我产生了要提高VPS安全性的想法。 Last failed login: Tue Feb 10 23:32:08 EST 2017 from static-15-64-34.rpnspl.com on ssh:nottyThere were 166 failed login attempts since the last successful login.Last login: Tue Feb 10 18:54:37 2017 from ip 这里的ip并不是我的IP地址，也就是说有人(或机器人)在恶意试探我的VPS密码。看到这提示，我马上上谷歌搜索，发现这个现象非常普遍，多数都是被机器人扫描然后试图暴力破解，如果不加以防范，代价会很大。 我在查问题的时候发现，PuTTY官方并没有提供中文版本，所以网上的汉化版有可能被植入后门，非常不安全，所以在此提醒，这一类涉及重要密码的软件绝对不要用民间汉化版！ 那么如何知道自己的VPS账号正在遭受扫描和暴力破解呢？简单的方法就是查看日志： 12345678910# 查看登录成功的用户信息last# 最新的登录记录在最前面，所以可以用以下命令来查看。last | less# 查看登录失败的用户信息lastb# 查看登录日志tail /var/log/secure 也可以执行以下命令，查询出来的结果中包含了ip地址=数量就是攻击者信息。 1cat /var/log/secure|awk '/Failed/&#123;print $(NF-3)&#125;'|sort|uniq -c|awk '&#123;print $2\"=\"$1;&#125;' 如何来增强VPS账号的安全性呢？除了养成使用正规软件的好习惯外，还要从VPS本身来加强VPS账号的安全性。 Linux有一个自动统计VPS登录错误的工具：Denyhosts，一旦登录VPS账号错误次数超过了Denyhosts的安全设置，Denyhosts就会将该IP记录下来，同时将其放入黑名单当中，禁止该IP在某一段时间内继续访问VPS，通过它可以实现自动封锁恶意IP 默认的SSH端口是22，通过修改自己的SSH端口先为扫描者增加一道端口门槛 VPS默认的账号是root，如果我们禁用了root，那么要攻破账号又得先暴力猜测VPS的账号，难度又增加几分 如果还不放心，我们可以直接禁用密码登录验证VPS的方式，改用密钥登录，这样安全系数是相当高了 注：本人主机为CentOS 7 x64系统，以下内容均基于此环境 Denyhosts攻击 Linux各平台现在基本上都可以直接安装Denyhosts了，直接运行命令安装 1yum install denyhosts 安装好了Denyhosts，默认的配置基本上就可以防御一定的暴力攻击了，/etc/hosts.deny文件里保存了被屏蔽的记录。 如果你要自定义Denyhosts的相关配置，执行：vi /etc/denyhosts.conf，相关参数的说明可以自行搜索，一般用户默认即可。 修改SSH端口输入命令 1vi /etc/ssh/sshd_config 编辑SSH服务的配置文件，找到#port 22，将前面的#去掉，然后将22修改为你自己设定的端口号，如12345，保存后重启SSH服务以使配置生效 1systemctl restart sshd.service 禁用Root账户禁用root账户之前，必须先新建一个新的账户。 12useradd user #添加用户名passwd user #为user用户设置密码 然后编辑配置文件 1vi /etc/ssh/sshd_config 找到里面的PermitRootLogin yes，将后面的yes改成no，如果没有这一行则直接加入即可。保存后重启SSH服务以使配置生效 1systemctl restart sshd.service 使用密钥登录生成密钥SSH登录方式有账号+密码和密钥认证两种形式，为了阻止暴力破解VPS的账号和密码，我们可以放弃密码验证的方式，改用密钥文件验证。 以普通用户(如user)执行以下命令，在VPS上生成密钥文件 1ssh-keygen -t rsa 生成密钥时会询问你密钥保存的位置，默认是/username/.ssh，保持默认即可，你还可以为你的密钥设置一个密码，默认为空。 密钥生成后，进入密钥存放的目录中，执行以下命令，将公钥生成一个新的文件。 1cat id_rsa.pub &gt;&gt; authorized_keys 将id-rsa这个私钥文件用winSCP下载到本地，打开PuTTYGen软件，执行Conversions-&gt;Import Key，导入这个私钥文件，然后选择Save private key，这时会在本地生成一个PPK文件，在PuTTY的Connection/SSH/Auth中选择刚刚保存的PPK文件，以后即可用密钥认证登录VPS了。 CentOS 7权限问题CentOS 7系统下，用户user的home目录：/home/user的权限变成了777，造成不能正常登陆SSH，报如下错误：Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password) SSH对公钥、私钥的权限和所有权的要求是非常严格的，总结如下：1、下面两个目录的所有权必须是user，所属组也应该是user，权限必须为700 /home/user/home/user/.ssh 2、下面公钥文件的所有权必须是user，所属组也应该是user，权限必须为644 /home/user/.ssh/authorized_keys 3、下面私钥文件的所有权必须是user，所属组也应该是user，权限必须是600 /home/user/.ssh/id_rsa 接着上面的操作，这次需要获取root权限，首先输入命令su再输入root密码获取root权限，然后依次执行以下命令 12345mkdir /etc/ssh/usercp /home/user/.ssh/authorized_keys /etc/ssh/user/chmod 755 /etc/ssh/userchmod 600 /etc/ssh/user/authorized_keyschown -R user:user /etc/ssh/user 编辑SSH配置文件1vi /etc/ssh/sshd_config 找到AuthorizedKeysFile这项(如果没有则添加)，修改为 1AuthorizedKeysFile /etc/ssh/%u/authorized_keys 保存后重启SSH服务以使配置生效 1systemctl restart sshd.service 禁止密码登录注意：请确认你已经可以通过密钥认证的方式登录VPS 有了密钥登录VPS，我们就可以禁止用密码登录这种验证方式了，还是编辑SSH配置文件 1vi /etc/ssh/sshd_config 找到PasswordAuthentication(没有则添加)并修改后面的yes为no，保存后重启SSH服务以使配置生效 1systemctl restart sshd.service 小结通过以上这些措施可以有效防范暴力破解VPS，平时使用官方软件也是提升安全性的一大举措，总而言之，没有绝对的安全，但是只要我们平时稍加留心就不会给破解者可乘之机。 参考链接：https://www.freehao123.com/vps-ssh/http://www.cnblogs.com/jxterminator/p/4105545.html","tags":[{"name":"VPS","slug":"VPS","permalink":"https://i-square.github.io/tags/VPS/"}]},{"title":"VPS搭建Shadowsocks服务和优化笔记","date":"2017-02-28T03:43:59.000Z","path":"post/VPS搭建Shadowsocks服务和优化笔记/","text":"前言由于最近开始上Github较多，无意中发现Github推出了一个学生开发者优惠大礼包，这对于囊中羞涩的学生来说真的是大大的福利，给Github一个大大的赞！ 这个优惠包里头包含很多开发者需要付费购买的服务或者工具的优惠券，其中有一个DigitalOcean的$50优惠券，对于一直想入一台VPS但又因为价格昂贵望而却步的我来说就是雪中送炭啊，于是我马上注册获取优惠券，随即开始折腾，这里把这两天折腾的过程记录一下。 前期准备 一台运行CentOS 7 x64系统的主机 PuTTY，Windows系统下登录远程主机的工具，一定要去官网下载，一些所谓的汉化版会夹带私货 winSCP，Windows系统下管理远程主机文件的工具，也去官网下载 说明：VPS是必不可少的，(附我的digitalocean推介码，注册即可获赠$10)，PuTTY用来在Windows系统下远程登录VPS，winSCP会用来下载密钥。 Shadowsocks配置首先使用PuTTY登录到你的VPS，方法就不赘述了，登录后切换到root账户。 安装shadowsocks服务一步一步执行以下命令，可以复制后在PuTTY中点击鼠标右键粘贴，回车执行，如询问(Y/N)，则输入Y回车。 12345yum install epel-releaseyum updateyum install python-setuptoolseasy_install pippip install shadowsocks 以上命令执行完之后，shadowsocks已安装到你的VPS中，但还没有运行。 配置shadowsocks服务运行shadowsocks需要一个配置文件，我们在/etc目录下新建一个配置文件。 1vi /etc/shadowsocks.json 按键盘i建进入编辑模式，复制以下内容，然后直接右键粘贴。请改“端口号”为你需要的端口号，范围1 ~ 65535，改“你的密码”为你自己的密码。 12345678910&#123; \"server\":\"0.0.0.0\", \"server_port\":端口号, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"你的密码\", \"timeout\":500, \"method\":\"aes-256-cfb\", \"fast_open\": true&#125; 粘贴后，按键盘Esc键退出编辑模式，输入:wq回车，保存并退出。上面这些参数应该不用多说了，用shadowsocks的都懂的。最后一项fast_open表示是否使用TCP_FASTOPEN（后面优化部分会打开系统的TCP_FASTOPEN，所以这里填true,否则填false) Supervisor监控进程配置好shadowsocks之后我们需要后台自启动服务，虽然目前shadowsocks自己也可以后台运行，但是如果有一个监控进程能在shadowsocks进程挂了之后重新启动它就更好了，supervisor就是用来监控进程的工具。 安装supervisor运行以下命令 12yum install python-setuptools supervisoreasy_install supervisor 配置supervisor以上命令执行完之后，supervisor已经安装，然后我们编辑/etc/supervisord.conf文件 1vi /etc/supervisord.conf 按键盘i建进入编辑模式，光标移到底部空行处，如没空行就在末尾回车加入空行，复制以下内容： 123456[program:shadowsocks]command=ssserver -c /etc/shadowsocks.jsonautostart=trueautorestart=truerestartretries=10user=nobody 复制完成后，回个车，为底部再留下空行，按键盘Esc键退出编辑模式，输入:wq回车，保存并退出。这样就完成了supervisor监控shadowsocks进程的配置，接下来需要让supervisor开机启动，这样才能达到我们的目的。 supervisor开机自启所幸，CentOS 7下supervisor开机启动非常的容易，User-contributed OS init scripts for Supervisor，这个Github项目提供各个系统下的supervisor服务开机启动脚本，其中centos-systemd-etcs就是我们需要的CentOS 7下面的脚本。 建议直接复制脚本内容，然后添加到目录/etc/systemd/system下。 1vi /etc/systemd/system/supervisord.service 按键盘i建进入编辑模式，粘贴脚本内容后按键盘Esc键退出编辑模式，输入:wq回车，保存并退出。然后运行 1systemctl enable supervisord.service 就完成了supervisor的开机启动，到此Shadowsocks已经在CentOS 7 x64下安装配置成功，运行命令 1reboot 重启服务器使服务生效，此时已经可以正常使用Shadowsocks服务。 Shadowsocks服务优化系统层面基于kvm架构vps的优化(DO的主机正好可以用) 优化内核参数vi /etc/sysctl.conf直接把以下内容复制粘贴进去 12345678910111213141516171819202122232425262728293031323334353637# max open filesfs.file-max = 1024000# max read buffernet.core.rmem_max = 67108864# max write buffernet.core.wmem_max = 67108864# default read buffernet.core.rmem_default = 65536# default write buffernet.core.wmem_default = 65536# max processor input queuenet.core.netdev_max_backlog = 4096# max backlognet.core.somaxconn = 4096# resist SYN flood attacksnet.ipv4.tcp_syncookies = 1# reuse timewait sockets when safenet.ipv4.tcp_tw_reuse = 1# turn off fast timewait sockets recyclingnet.ipv4.tcp_tw_recycle = 0# short FIN timeoutnet.ipv4.tcp_fin_timeout = 30# short keepalive timenet.ipv4.tcp_keepalive_time = 1200# outbound port rangenet.ipv4.ip_local_port_range = 10000 65000# max SYN backlognet.ipv4.tcp_max_syn_backlog = 4096# max timewait sockets held by system simultaneouslynet.ipv4.tcp_max_tw_buckets = 5000# TCP receive buffernet.ipv4.tcp_rmem = 4096 87380 67108864# TCP write buffernet.ipv4.tcp_wmem = 4096 65536 67108864# turn on path MTU discoverynet.ipv4.tcp_mtu_probing = 1 保存生效sysctl -p TCP优化1.修改文件句柄数限制ubuntu/centos均可修改/etc/sysctl.conf找到fs.file-max这一行，修改其值为1024000，并保存退出。然后执行sysctl -p使其生效修改vi /etc/security/limits.conf文件，加入 12* soft nofile 512000* hard nofile 1024000 针对centos,还需要修改vi /etc/pam.d/common-session文件，加入session required pam_limits.so 2.修改vi /etc/profile文件，加入ulimit -SHn 1024000然后重启服务器执行ulimit -n，查询返回1024000即可。 1234567sysctl.conf报错解决方法修复modprobe的：rm -f /sbin/modprobe ln -s /bin/true /sbin/modprobe修复sysctl的：rm -f /sbin/sysctl ln -s /bin/true /sbin/sysctl #### 锐速锐速官方已不再维护免费版本，目前破解版支持的内核太旧，放弃。 开启TCP Fast Open这个前提条件是需要服务器是Linux 3.7+的内核，如果满足条件，那就在服务端的vi /etc/sysctl.conf文件中再加上一行。 12# turn on TCP Fast Open on both client and server sidenet.ipv4.tcp_fastopen = 3 然后记得把vi /etc/shadowsocks.json配置文件中”fast_open”:配置为true。这样速度也将会有非常显著的提升。 开启TCP BBR拥塞控制算法BBR 目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 效果并不比速锐差Linux kernel 4.9 已支持 tcp_bbr 下面简单讲述如何开启 下载更换内核最新内核查看这里 123rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpmyum --enablerepo=elrepo-kernel install kernel-ml -y 查看内核是否安装成功 1rpm -qa | grep kernel 更新 grub 系统引导文件 1vi /etc/default/grub 修改对应的字段为 GRUB_DEFAULT=0，然后重新编译启动项 1grub2-mkconfig -o /boot/grub2/grub.cfg 删除旧内核(可选) 1yum remove kernel 最后重启reboot生效。 注意，某些服务商可能需要首先将VPS配置为可自定义内核，然后grub2的配置才会生效。 开启bbr 开机后 uname -r 看看内核是不是最新的，至少要大于4.9 执行 12echo \"net.core.default_qdisc=fq\" &gt;&gt; /etc/sysctl.confecho \"net.ipv4.tcp_congestion_control=bbr\" &gt;&gt; /etc/sysctl.conf 保存生效sysctl -p 执行 12sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control 如果结果都有bbr, 则证明你的内核已开启bbr 执行lsmod | grep bbr看到有 tcp_bbr 模块即说明bbr已启动 加密层面安装M2Crypto这个可以提高SS的加密速度，安装办法:先安装依赖包：yum install -y openssl-devel gcc swig python-devel autoconf libtool安装setuptools: 12wget --no-check-certificate https://raw.githubusercontent.com/iMeiji/shadowsocks_install/master/ez_setup.pypython ez_setup.py install 再通过pip安装M2Crypto:pip install M2Crypto或者pip install M2Crypto --upgrade 2.2 安装 gevent安装 gevent可以提高 Shadowsocks 的性能。 CentOS 123yum install -y libeventpip install greenletpip install gevent 使用CHACHA20加密算法首先，安装libsodium，让系统支持chacha20算法。 CentOS 123456789101112yum groupinstall &quot;Development Tools&quot;wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gztar zxf LATEST.tar.gzcd libsodium* ./configuremakemake installvi /etc/ld.so.conf添加一行：/usr/local/lib保存退出后，运行命令：ldconfig 然后修改ss加密方式:vi /etc/shadowsocks.json“method”:”aes-256-cfb”改成”method”:”chacha20”. 网络层面此外，选择合适的端口也能优化梯子的速度，广大SS用户的实践经验表明，检查站（GFW）存在一种机制来降低自身的运算压力，即常用的协议端口（如http，smtp，ssh，https，ftp等）的检查较少，所以建议SS绑定这些常用的端口（如：21，22，25，80，443），速度也会有显著提升。如果你还要给小伙伴爬，那我建议开启多个端口而不是共用，这样网络会更加顺畅。 防火墙设置（如有）自动调整MTUiptables -I FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu 开启 NAT （记得把 eth0 改成自己的网卡名）iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 开启 IPv4 的转发sysctl -w net.ipv4.ip_forward=1 打开 443 端口12iptables -I INPUT -p tcp --dport 443 -j ACCEPTiptables -I INPUT -p udp --dport 443 -j ACCEPT 重启防火墙iptables：service iptables restart 结语至此，这几天配置shadowsocks的过程便结束了，这里只是将我遇到的情况加以记录，并不能涵盖所有情况，如果碰到其他状况，那么google就好了。 :P","tags":[{"name":"VPS","slug":"VPS","permalink":"https://i-square.github.io/tags/VPS/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://i-square.github.io/tags/Shadowsocks/"}]},{"title":"新的起点","date":"2017-02-25T09:27:39.000Z","path":"post/新的起点/","text":"前言从2013年我搭建的第一个Wordpress博客开始，我陆陆续续尝试过各种博客类网站，有自己搭建的Wordpress博客，也有诸如点点网和lofter这样的轻博客社区，但最终都是留下一篇hello world走人。 缘起近两年随着github的火热，搭建在github pages上的博客也如雨后春笋一般噌噌地冒出来，我也想尝尝鲜，于是在大谷歌搜索到一篇文章：使用GitHub和Hexo搭建免费静态Blog，作者：wsgzao，然后照猫画虎搭建了自己的博客，非常感谢原文博主分享自己的经验，让我这个门外汉也能轻松上手。 展望这次使用Hexo + github的博客我希望能够长时间更新下去，博客定位大方向是我自己的学习笔记、思考感悟，也会写一些生活随笔，说不定也会分享一些图片、音乐、视频等等，:) 多说点儿刚开始学习用Markdown写文章，还不是太习惯，用到的语法也只有一两种，慢慢完善吧，:P","tags":[{"name":"博客","slug":"博客","permalink":"https://i-square.github.io/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://i-square.github.io/tags/hexo/"},{"name":"Github","slug":"Github","permalink":"https://i-square.github.io/tags/Github/"}]},{"title":"Post Test 发布测试","date":"2017-02-24T06:33:36.000Z","path":"post/Post-Test-发布测试/","text":"测试首先发布一篇测试文章，以后慢慢扩充。 龟速学习Markdown语法ing。","tags":[{"name":"test","slug":"test","permalink":"https://i-square.github.io/tags/test/"}]},{"title":"Hello World","date":"2017-02-23T07:15:45.000Z","path":"post/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"test","slug":"test","permalink":"https://i-square.github.io/tags/test/"}]}]