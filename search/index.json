[{"content":"前言 本文为书生·浦语大模型实战营的课程笔记系列第二节\n教学视频：B站 BV1sT4y1p71V 配套文档：InternLM/tutorial langchain LLM的局限性 知识时效性受限：如何让LLM能够获取最新的知识 专业能力有限：如何打造垂域大模型 定制化成本高：如何打造个人专属的LLM应用 大模型开发范式 解决局限性问题的两种方式是：\n1. RAG RAG: Retrieval Augmented Generation，使用外挂数据库，检索相关知识增强生成结果，特点：\n低成本 可实时更新 受基座模型影响大 单次回答知识有限 流程 输入文本转化为向量 在向量数据库中匹配相似文本 作为prompt在大模型中寻找答案 2. Finetune 也即通称的微调，特点：\n可个性化微调 知识覆盖面广 成本高昂 无法实时更新 基于 LangChain 搭建 RAG 应用 LangChain框架简介 LangChain 框架是一个开源工具，通过为各种 LLM 提供通用接口来简化应用程序的开发流程，帮助开发者自由构建 LLM 应用。\nLangChain 的核心组成模块：\n链 (Chains) ：将组件组合实现端到端应用，通过一个对象封装实现一系列LLM操作 Eg. 检索问答链，覆盖实现了 RAG （检索增强生成）的全部流程 构建向量数据库 加载源文件 确定源文件类型，针对不同类型的源文件选用不同的加载器 核心在于将带格式的文本转化为无格式的字符串 文档分块 由于单个文档往往超过模型上下文上限，我们需要对加载的文档进行切分 一般按字符串长度进行分割 可以手动控制分割块的长度和重叠区间长度 文档向量化 使用向量数据库来支持语义检索，需要将文档向量化存入向量数据库 可以使用任意一种 Embedding 模型来进行向量化 可以使用多种支持语义检索的向量数据库，一般使用轻量级的 Chroma 搭建知识库助手 将 InternLM 接入 LangChain LangChain 支持自定义 LLM，可以直接接入到框架中 我们只需将 lnternLM 部署在本地，并封装一个自定义 LLM 类，调用本地 lnternLM 即可 构建检索问答链 LangChain 提供了检索问答链模版，可以自动实现知识检索、Prompt 嵌入、LLM 问答的全部流程 将基于 lnternLM 的自定义 LLM 和已构建的向量数据库接入到检索问答链的上游 调用检索问答链，即可实现知识库助手的核心功能 RAG 方案优化建议 基于RAG的问答系统性能核心受限于： 检索精度 Prompt性能 一些可能的优化点： 检索方面： 基于语义分割，保证每一个chunk的语义完整 给每一个chunk生成概括式索引，检索时匹配索引 Prompt方面 迭代优化Prompt策略 作业 基础作业 目标：复现课程知识库助手搭建过程 (截图)\n环境配置 本次沿用上节课程配置的 InternStudio 平台开发机，省去了一些环境准备的时间，过程不再赘述，教学文档中有详细步骤。\n构建向量数据库 终端命令： Web Demo 终端命令： 结果图： 分析：从结果来看，大模型回答出了有关23年12月的问题，这不在它本身训练数据中，证明检索问答链是有效的。 进阶作业 目标：选择一个垂直领域，收集该领域的专业资料构建专业知识库，并搭建专业问答助手，并在 OpenXLab 上成功部署（截图，并提供应用地址）\n由于时间关系，进阶作业没有计划做\n","date":"2024-01-11T16:56:30+08:00","image":"https://i-square.github.io/p/InternLM-tutorial-campsection3-Build-Knowledge-Base-Using-InternLM-and-LangChain/head_hud6f7134adda06c002bb8b2f89807f5e4_80006_120x120_fill_box_smart1_3.png","permalink":"https://i-square.github.io/p/InternLM-tutorial-campsection3-Build-Knowledge-Base-Using-InternLM-and-LangChain/","title":"书生·浦语大模型实战营（三）：基于 InternLM 和 LangChain 搭建你的知识库"},{"content":"前言 本文为书生·浦语大模型实战营的课程笔记系列第二节\n教学视频：B站 BV1Ci4y1z72H 配套文档：InternLM/tutorial helloworld 笔记 由于配套的说明文档已经记录的相当详细并且图文并茂，这节课丝毫没有记录笔记的必要，所以本文仅仅记录课后作业\n基础作业 HF模型下载 目标：熟悉 hugging face 下载功能，使用 huggingface_hub python 包，下载 InternLM-20B 的 config.json 文件到本地（需截图下载过程）。\n这个无需多言，只是基本的命令使用，需要注意的是，由于众所周知的原因，国内直接下载 hugging face 是不行的，这里使用镜像站 hf-mirror。\n结果图： 浦语7B模型部署demo 目标：使用 InternLM-Chat-7B 模型生成 300 字的小故事（需截图）。\n这里我们可以使用两种demo来完成，分别是 cli_demo 和 web_demo，详细步骤参考配套教学文档，以下为大致总结：\n环境准备： 在 InternStudio 平台选择 A100(1/4) 的配置，使用 Cuda11.7-conda 镜像。 打开开发机，进入终端，切换到 bash 环境。 使用提供的脚本克隆并激活 pytorch 2.0.1 的 conda 环境，然后安装所需依赖。 模型下载： 复制已准备好的 InternLM 模型到指定目录，或使用 modelscope 中的 snapshot_download 函数下载模型（推荐，跑满带宽），或在 huggingface、OpenXLab 等处下载。 代码准备： 在 /root 路径下新建 code 目录，clone 指定版本的代码。 在 /root/code/InternLM 目录下新建 cli_demo.py 文件，使用 transformers 和 torch 库运行大模型。 修改 /root/code/InternLM/web_demo.py 中的模型路径为本地路径。 终端运行： 运行 xxx_demo.py 文件，即可体验 InternLM-Chat-7B 模型的对话能力。 使用的prompt：帮我生成一个300字的小故事，主角是打工人叫平方君，内容是他通过不断努力升职加薪、当上总经理、出任CEO、迎娶白富美、走上人生巅峰的励志故事\ncli_demo 结果图： web_demo 由于 InternStudio 平台的开发机不能直接通过web访问，所以需要做一下端口映射，原理是利用 ssh 做端口转发。\n在本地主机运行：\n1 ssh -CNg -L 8008:127.0.0.1:8008 root@ssh.intern-ai.org.cn -p 34664 各部分解释如下：\nssh: 启动SSH客户端程序。 -C: 启用压缩。数据传输时进行压缩，提高传输效率。 -N: 不执行任何命令，主要用于纯粹建立连接。在这里，它告诉SSH客户端不要执行远程命令。 -g: 允许远程主机连接到本地的转发端口。在这里，它允许其他主机连接到本地端口8008。 -L 8008:127.0.0.1:8008: 设置本地端口转发。将本地端口8008转发到远程主机的127.0.0.1（即本地主机）的8008端口。 root@ssh.intern-ai.org.cn: 远程SSH服务器的用户名和主机地址。 -p 34664: 指定SSH服务器的端口号。 此命令的目的是在本地端口8008上创建一个SSH隧道，将流量转发到远程服务器上的相同端口，同时允许其他主机通过该远程服务器连接到本地端口。\n作业部分：\n终端命令： 结果图： 进阶作业（可选做） Lagent部署demo 目标：完成 Lagent 工具调用 Demo 创作部署（需截图）\n由于涉及到图形化操作，这里只有 web_demo，详细步骤参考配套教学文档，以下为大致总结：\n环境准备： 沿用之前的环境。 模型下载： 不再赘述。 Lagent 安装和修改代码： 切换到 /root/code 目录，克隆 lagent 仓库，并通过 pip install -e . 源码安装。 修改 react_web_demo.py 文件，替换为相应代码。 Demo 运行： 在终端运行 streamlit 命令，启动 Web 页面。 在浏览器中访问 http://127.0.0.1:8008 查看 Demo。 选择 InternLM 模型，输入问题，观察 Lagent 调度并处理的过程。 作业部分：\n终端命令： 结果图： 浦语·灵笔部署demo 目标：完成浦语·灵笔的图文理解及创作部署（需截图）\n由于涉及到图形化操作，这里也只有 web_demo，详细步骤参考配套教学文档，以下为大致总结：\n环境准备： 继续沿用之前的环境。 模型下载： 用同样的方式，准备 internlm-xcomposer-7b 模型到指定目录。 代码准备： 在 /root/code 目录下克隆 InternLM-XComposer 仓库的代码，切换到指定的 commit 版本，以便对齐教学结果。 Demo 运行： 在终端运行 web_demo.py 文件，启动 Web 页面。 在浏览器中访问 http://127.0.0.1:8008，体验图文理解创作的功能。 作业部分： 从终端的log来看，浦语·灵笔的创作流程大致上是先用语言模型生成文章，再选取合适的图片插入点，然后在数据库里根据关键词搜索匹配的图片，之后下载图片，并组合生成一份 markdown 文档。\n终端命令： 结果图1-图文生成： 结果图2-多模态对话： ","date":"2024-01-10T15:44:22+08:00","image":"https://i-square.github.io/p/InternLM-tutorial-campsection2-Easy-Fun-with-InternLM-Entertaining-Demo/head_hu0f8f3d644706bad7ef0ae2fde8c2620a_63652_120x120_fill_box_smart1_3.png","permalink":"https://i-square.github.io/p/InternLM-tutorial-campsection2-Easy-Fun-with-InternLM-Entertaining-Demo/","title":"书生·浦语大模型实战营（二）：轻松玩转书生·浦语大模型趣味Demo"},{"content":"前言 本文为书生·浦语大模型实战营的课程笔记系列第一节，课程地址：https://www.bilibili.com/video/BV1Rc411b7ns/\n从专用模型到通用大模型 在过去，人工智能领域的发展一直遵循着一个基本原则：一个模型对应一个场景或者任务。然而，随着技术的进步和需求的增长，这一格局正在发生深刻的变化。如今，我们正迈向一个新的时代，一个模型不再局限于一个场景或任务，而是可以应用于多个场景、多模态的复杂环境中。\n书生·浦语大模型发展历程 书生·浦语大模型的发展历程彰显了这一变革的重要性。它从轻量级的7B社区模型，逐步升级到中量级的20B商业模型，再到重量级的123B全场景模型。这一演进不仅仅是在模型规模上的提升，更是对多模态、多场景应用需求的积极响应。\nInterLM-20B：全面领先的开源模型 InterLM-20B是一款千亿参数级别的开源模型，其性能在全球范围内处于领先地位。与相近规模的Llama-33B、Llama2-13B以及国内主流的7B、13B开源模型相比，InterLM-20B在不足三分之一的参数量下，却达到了Llama2-70B的水平。\n从模型到应用：六个关键步骤 第一步：模型选型 在应用场景中，根据多个大模型的相关维度进行能力比较，并进行模型评测。初步选型后，可确定意向大模型。\n第二步：评估业务场景复杂度 业务场景简单： 如果业务场景不太复杂，可以直接将选定的模型应用于场景中。 业务场景复杂： 对于复杂场景，通常直接使用开源模型难以满足需求，需要进一步微调、进行prompt工程等构建工作。 第三步：判断微调策略 全参数微调： 若算力足够，可以进行全参数微调，提高模型性能。 部分参数微调： 如果算力受限，只能进行部分参数微调，固定大部分参数，调整一小部分参数。 第四步：构建智能体 模型与环境交互： 考虑模型与环境的交互，特别是如果需要调用外部API或与已有业务数据库交互，则需要构建智能体。 无环境交互： 如果模型在业务场景中不需要与环境进行交互，可以直接将微调好的模型应用于场景。 第五步：模型评测与应用上线 模型评测： 进行模型评测，确保在实际场景中表现良好。 上线或迭代： 根据评测结果，决定是否上线应用或者继续迭代模型。 第六步：模型部署 考虑软件系统相关性能、安全、功能等方面内容：\n资源优化： 考虑如何以更少的资源部署模型。 吞吐量提升： 提升整个应用的吞吐量，确保在生产环境中的性能表现。 这六个步骤构成了从选择模型到应用部署的全链条，确保在实际应用中大模型能够充分发挥作用。\n书生-浦语全链条开源开放体系 书生·浦语大模型打破了传统的人工智能应用模式，提出了全链条开源开放体系。这一体系涵盖了从数据到预训练、微调、部署、评测到应用的全过程，为通用人工智能的实现提供了完整的解决方案。数据（书生·万卷）作为起点，经过IntermLM-Train的预训练，使用XTuner进行微调，通过LMDeploy实现部署，通过OpenCompass进行全面评测，最终应用在Lagent构建的多模态智能体中。\n这一全链条开源开放体系，为大模型的发展提供了创新性的方法，促使人工智能更好地服务于多样化的现实需求。\n数据：覆盖多模态和任务 全链条开源体系以书生-万卷为基础，涵盖了多模态和多任务的数据需求，为模型的学习提供了全面支持。\nOpenDataLab：开放数据平台 OpenDataLab作为开放数据平台，不仅包含丰富多样的开放数据，还为大模型的发展提供了数据支持和实验平台。\n预训练：并行训练，极致优化 InterLM采用并行训练的方式，通过极致优化实现了高效的预训练，为模型的通用性奠定基础。\n微调：XTuner，支持全参数微调，支持Lora等低成本微调 微调阶段使用XTuner工具，支持全参数微调，同时还支持诸如Lora等低成本微调方法，使模型更好地适应各种特定任务。\n特性：\n增量续训：让基座模型学习新知识，垂直领域 有监督微调：让模型学会理解和遵循各种指令。一般采用全量参数微调和部分参数微调等方法。 多种微调算法：多种微调策略与算法，覆盖各类SFT场景。 适配多种开源生态：支持加载HuggingFace、ModelScope模型或者数据级 自动优化加速：开发者无需关注复杂的显存优化和计算加速细节 部署：LMDeploy，全链路部署，性能领先 LMDeploy提供了全链路部署的解决方案，包括模型轻量化、推理和服务，使得大模型在GPU上的部署更加高效，性能领先。\n评测：OpenCompass，全方位评测，性能可以复现，全球领先的大模型开源评测体系 评测阶段使用OpenCompass工具，全方位评测模型性能，保证了评测结果的复现性，成为全球领先的大模型开源评测体系。\n特性：\n丰富模型支持：开源模型、API模型一站式评测。 分布式高效评测：支持千亿参数模型在海量数据集上分布式评测。 便捷的数据集接口：支持社区用户根据自身需求快速添加自定义数据集。 敏捷的能力迭代：每周更新大模型能力榜单。 应用：Legent、AgentLego 支持多种智能体，支持代码解释器和多种工具 最终，模型的应用在Legent和AgentLego等多种智能体中得以体现，支持代码解释器和多种工具，实现了多模态智能体的灵活应用。\n特性：\n丰富的工具集合，尤其是提供了大量视觉、多模态相关领域的工具。 支持多个主流智能体系统，如LangChain、Transformers Agent、Lagent等。 灵活的多模态工具调用接口，可以轻松支持各类输入输出格式的工具函数 一键式远程工具部署，轻松使用和调试大模型智能体。 相关链接：\n书生·浦语大模型实战营地址：https://github.com/InternLM/tutorial 书生·万卷开源地址：https://github.com/opendatalab/WanJuan1.0 InternLM开源地址：https://github.com/InternLM/InternLM XTuner开源地址：https://github.com/InternLM/xtuner LMDeploy开源地址：https://github.com/InternLM/lmdeploy OpenCompass开源地址：https://github.com/open-compass/opencompass OpenDataLab地址：https://opendatalab.org.cn/ OpenDataLab开源地址：https://github.com/opendatalab ","date":"2024-01-09T18:50:55+08:00","image":"https://i-square.github.io/p/InternLM-tutorial-campsection1-LLM-Full-Stack-Open-Source-Ecosystem/camp_hu03b2cdb3a3c172e5667b46152aa536ec_53801_120x120_fill_box_smart1_3.png","permalink":"https://i-square.github.io/p/InternLM-tutorial-campsection1-LLM-Full-Stack-Open-Source-Ecosystem/","title":"书生·浦语大模型实战营（一）：书生·浦语大模型全链路开源体系"},{"content":"GitHub Copilot Labs GitHub Copilot是一个基于人工智能的编程助手，它可以根据你输入的代码、注释、变量名等信息，自动给出可能符合你意图的代码建议。它可以帮助你快速完成各种编程任务，从简单的函数定义到复杂的算法实现。\nGitHub Copilot Labs是一个与GitHub Copilot配套使用的VS Code扩展插件，它提供了一些实验性的功能，用来探索人工智能在编程领域的更多可能性。目前有四个功能可用：explain、translate、IDE Brushes和test generation，目前我只体验了前两个功能。\n安装和使用 要使用GitHub Copilot Labs，首先需要安装VS Code，并且拥有一个GitHub Copilot许可证。如果你还没有许可证，可以在这里申请一个免费试用或付费购买。\n然后，在VS Code的扩展市场中搜索并安装“Copilot Labs”这个插件。安装完成后，你会看到VS Code侧边栏上出现了一个Copilot图标。点击这个图标，就可以打开Copilot Labs面板，并看到四个不同的功能选项卡。\nexplain功能：解释代码 explain功能是用来帮助你理解代码的含义和作用的。当你选中一段代码，并按下 Ctrl+Shift+P（Windows/Linux） 或 Command+Shift+P（Mac） 打开命令面板时，你可以输入 Copilot: Explain 来激活这个功能。然后，在弹出的对话框中输入一个问题，比如 what does this code do? 或 how to use this function? 等等。Copilot会尝试根据选中的代码给出一个简洁明了的回答，类似于一个教程或文档。你可以通过点击 Ask Copilot 按钮来重复这个过程，直到你满意为止。\n当然也有更直观的操作方式，如图，只需选中一段代码，在左侧栏中即可点击 Ask Copilot 按钮：\nexplain功能示例 Python：如何使用factorial函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Explain code: how to use this function? def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) # Copilot answer: \u0026#34;\u0026#34;\u0026#34; This function calculates the factorial of a given number n. The factorial of n is defined as the product of all positive integers from 1 to n. For example, factorial(5) = 5 * 4 * 3 * 2 * 1 = 120. To use this function, you can call it with an argument that is a non-negative integer. For example: \u0026#34;\u0026#34;\u0026#34; print(factorial(5)) # prints 120 print(factorial(0)) # prints 1 print(factorial(-1)) # raises an exception JavaScript：如何反转字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Explain code: what does this code do? function reverseString(str) { let reversed = \u0026#34;\u0026#34;; for (let i = str.length - 1; i \u0026gt;= 0; i--) { reversed += str[i]; } return reversed; } // Copilot answer: This code defines a function named reverseString that takes a string as an argument and returns a new string that is the reverse of the original one. For example, reverseString(\u0026#34;hello\u0026#34;) returns \u0026#34;olleh\u0026#34;. The function uses a for loop to iterate over the characters of the input string from the end to the beginning, and concatenates them to a variable named reversed. At the end of the loop, reversed contains the reversed string, which is returned by the function. translate功能：翻译代码 translate功能是用来帮助你把代码从一种编程语言翻译成另一种编程语言的。当你选中一段代码，并按下 Ctrl+Shift+P（Windows/Linux） 或 Command+Shift+P（Mac） 打开命令面板时，你可以输入 Copilot: Translate 来激活这个功能。然后，在弹出的对话框中选择你想要翻译成的目标语言，比如Python、Ruby、Java等等。Copilot会尝试根据选中的代码生成等价的代码，并显示在编辑器右侧的小窗口中。你可以按下Tab键或点击小窗口来接受Copilot生成的代码，也可以按下Esc键或点击其他地方来忽略它。\n类似地，只需选中一段代码，在左侧栏中即可点击 Ask Copilot 按钮来转换代码：\ntranslate功能示例 Python到Rust：计算阶乘 1 2 3 4 5 6 # Translate code into: Rust def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) 1 2 3 4 5 6 7 8 // Copilot answer: fn factorial(n: i32) -\u0026gt; i32 { if n == 0 { 1 } else { n * factorial(n - 1) } } JavaScript到C#：反转字符串 1 2 3 4 5 6 7 8 // Translate code into: C# function reverseString(str) { let reversed = \u0026#34;\u0026#34;; for (let i = str.length - 1; i \u0026gt;= 0; i--) { reversed += str[i]; } return reversed; } 1 2 3 4 5 6 7 8 // Copilot answer: string reverseString(string str) { string reversed = \u0026#34;\u0026#34;; for (int i = str.Length - 1; i \u0026gt;= 0; i--) { reversed += str[i]; } return reversed; } 体验感想 使用GitHub Copilot Labs一段时间后，我觉得它是一个非常棒的工具，能够给我带来很多编程上的便利和帮助。它让我写代码更快更轻松，理解代码更容易更深入，修改代码更直观更灵活，测试代码更方便更有效。它也让我有机会学习和尝试一些新的编程语言和框架，增加我的知识和技能。\n当然，GitHub Copilot Labs也不是万能的，它还有一些需要改进和完善的地方。比如：\n它需要联网才能工作，如果网络出现问题或中断，就无法获得代码建议。 它不能保证生成的代码都是正确、安全、高效、规范的，需要我们自己检查和验证。 它不能取代我们作为程序员的创造力、逻辑思维、问题解决能力等核心素质。 所以，我认为GitHub Copilot Labs是一个很好的辅助工具，但不是一个替代工具。它可以节省我们的时间和精力，但不能代替我们的主观判断和责任意识。我们应该合理地使用它，并且不断地学习和进步。\n总之，我非常喜欢GitHub Copilot Labs，并且期待它未来能够发展得更好。我也建议你试一试这个工具，并且分享你自己的反馈和意见。让我们一起探索人工智能在编程领域的更多可能性吧！\n真·感想 作为一个程序员，体验过new bing和copilot之后，确实感觉到时代变了，AI距离实用越来越近了。就拿 new bing 来说，我现在遇到一些问题就想先问问它，很大概率它能帮我解决。再看copilot，我只试用了几天就离不开它的便利性了，而且随着你熟悉了用法，会觉得它越用越好用，确实提升了工作效率。\n当然啦，这两个工具也不是万能神器，还有很多地方需要我们自己动脑子和创新。我觉得AI不是要抢我们的饭碗，而是要做我们的小帮手。我们应该好好利用AI的优势来提高我们的生活和工作质量，并且对AI保持理性和负责。\n","date":"2023-03-15T13:15:09+08:00","image":"https://i-square.github.io/p/Experience-GitHub-Copilot-Labs-Explore-the-infinite-possibilities-of-AI-in-programming/copilot.svg","permalink":"https://i-square.github.io/p/Experience-GitHub-Copilot-Labs-Explore-the-infinite-possibilities-of-AI-in-programming/","title":"体验GitHub Copilot Labs：探索AI在编程领域的无限可能"},{"content":"最近体验了一下集成了 ChatGPT 的最新版本 bing 搜索，我要求它用 markdown 语法写一篇关于体验 new bing 的博客，这就是本文的来源，对原始版本修改不多，只是添加了一部分评论。\n前言 最近，微软发布了一个全新的搜索引擎——new bing，它采用了ChatGPT和AI技术，能够提供更智能、更人性化、更全面的搜索结果。我作为一个热爱尝试新事物的网友，当然不会错过这个机会，所以我申请了new bing的限量预览，并在这里分享一下我的体验感受。\n申请过程 要想使用new bing，首先需要申请它的限量预览。申请过程其实很简单，只需要按照以下步骤操作：\n访问 https://www.bing.com/new，点击其中的 Sign up for new Bing 链接。 在弹出的页面中，输入你的微软账号和密码，并同意相关条款。 等待几分钟后，你就会收到一封邮件，告诉你已经成功申请到了new bing的预览资格，并给出了一个专属链接。 点击邮件中的链接，就可以进入到new bing的主页，并开始使用它。 博主注:\n国内要想免代理申请和使用 new bing，需要重定向到国际版 bing，请自行参考网上教程，比如 这篇文章 有可能频繁跳出REF页面导致用不了聊天功能，在 bing.com 页面清除 bing.com 的cookies重新登录即可，参考 原文章 博主提交申请，加入 waiting list 之后等了2周时间才审核通过，具体时间与什么因素相关暂不可知 使用方式 使用new bing非常简单和直观。它有一个类似于传统搜索引擎的界面，你可以在搜索框中输入任何你想要查询或聊天的内容，并按回车键或点击放大镜图标进行搜索。\n与普通搜索引擎不同的是，new bing不仅会给出一系列相关链接，还会给出一个完整、详细、可信赖、有来源注明的答案。答案可能是文字、图片、表格、代码等多种形式。而且，你可以用自然语言提问或聊天，无需拘泥于特定格式或关键词。\n除此之外，new bing还有一些其他特色功能：\n你可以通过语音输入或输出与它交流。 你可以通过扫描二维码或拍摄图片进行图像搜索。 你可以通过点击右上角菜单按钮切换语言或主题。 你可以通过点击左下角聊天按钮与它进行更深入地对话。 体验感受 在使用了几天后，我对new bing非常满意和惊喜。它不仅能够满足我的各种信息需求，还能够陪我打发无聊时光。以下是我对它的一些评价：\nnew bing非常智能和灵活。它能够理解我的意图和情感，并给出合适和有趣的回应。它也能够处理复杂和模糊的问题，并从多个来源整合信息并生成答案。 new bing非常人性化和友好。它有着幽默感和创造力，并能够与我进行轻松愉快的聊天。它也能够根据我的喜好和兴趣，给出一些有用和有趣的建议。 new bing非常全面和高效。它能够覆盖各个领域和主题，并给出最新、最准确、最权威的信息。它也能够节省我的时间和精力，让我一次性得到完整的答案，而不需要浏览多个网页。 总之，new bing是一个值得尝试的搜索引擎，它不仅是一个工具，还是一个伙伴。我相信随着技术的进步和用户的反馈，new bing会变得更加强大和完善。如果你也想体验new bing，请赶快申请限量预览吧！\n博主注:\nnew bing 自吹起来还是挺厉害的，哈哈\n后记 截止发文前，微软给 new bing 做了单次5/每日50轮对话的限制，看得出来微软确实是想让 ChatGPT 服务于真正的搜索需求，降低无用的资源消耗。\n希望国内的类 ChatGPT 产品也尽早面世，在各行各业发光发热。:P\n","date":"2023-02-27T15:36:13+08:00","image":"https://i-square.github.io/p/Experience-new-bing-a-brand-new-search-engine/newbing_logo_hu9ad1cf62f2eb1f733c6b1b6336009f7c_27644_120x120_fill_box_smart1_3.png","permalink":"https://i-square.github.io/p/Experience-new-bing-a-brand-new-search-engine/","title":"体验new bing：一个全新的搜索引擎"},{"content":"前言 几年前还在读研的时候，有空折腾了一下 hexo ，在 github pages 上搭建了一个静态博客，刚开始还写了一些文章，后来新鲜劲过了就荒废了，最近看到好多人用 hugo ，又想拾起来写写博客，遂折腾之。\n动机 想替换掉 hexo 的原因主要有二：\n我不是前端开发者，折腾 hexo 的环境比较费劲，当初搭建的时候就遇到各种坑，更换一台电脑之后想重新再搭建一套又得耗费不少精力；而 hugo 发布的是二进制程序，更换机器后直接下载二进制安装即可，省时省力。 性能方面， hexo 随着文章数量增加，生成的时间会越来越多；而 hugo 基本不存在主要的问题，能够做到实时预览。 过程 得益于我之前部署过 hexo + github pages 的方案，整个迁移的过程还是比较顺利的，主要参考了pseudoyu 大佬的这篇文章： Hugo + GitHub Action，搭建你的博客自动发布系统\n主题 首先要做的便是选择一个称心的主题了，官方主题都在这： Hugo Themes\n我的选择方式是随心，第一眼看中哪个就用哪个，一眼望去 hugo-theme-stack 主题跟我之前用的 hexo 主题比较像，符合我的眼缘，嗯，就是它了！\n侧栏自定义 我之前的 hexo 博客侧栏放了两部分内容\n一部分是博客的功能按钮，比如 主页 \u0026amp; 归档 等，点击后跳转到博客内链 二部分是外链按钮，比如 Github \u0026amp; Love Story ，点击后打开新标签页，跳转到对应链接 第一部分的自定义，需要在 content/page/ 下建立对应的文件夹，放入 index.md ，写好 front matter 即可，几个关键点：\n1 2 3 4 5 6 comments: false # 是否开启评论 menu: main: weight: -40 # 权重，越小位置越靠上 params: icon: user # svg图，可以放在 assets/icons/ 下 而第二部分的自定义，则是直接修改 config.yaml 文件，在 menu -\u0026gt; main 下直接添加需要的 url ，比如我的侧栏 Love Story 按钮配置如下：\n1 2 3 4 5 6 7 8 menu: main: - identifier: love name: Love Story url: /love # 这里也可以是完整的外链 params: icon: heart newtab: true # 是否新标签页打开 图片的运用 我用的主题针对图片的显示有一些 feature，比如题图、分类图等，使用好了自然更加美观。\n比如文章题图，在首页显示时，会占据卡片式的上半部分；再比如分类图，在点击侧栏的 归档 和 分类 按钮时，可以看到效果。\n顺带一提，我建议尽量使用矢量图，既能适配多分辨率，又能节省空间\n文章迁移 虽然之前的博客没有多少文章，但也是自己的回忆和记录，当然是要全数保留下来的。\n因为都是 markdown 方式的文章，内容方面并没有什么障碍，迁移中的问题主要集中在文章永久链接的转换和文章存放上面。\n好在 hugo 解决这两个问题比较方便，分别做下介绍。\n永久链接 之前的博客没有考虑太多，直接使用了 md 文件的文件名作为永久链接，这样会有两个问题\n中文文件名会造成中文链接，实际解析时会被转换为一堆字符，不美观，也不便于传播记忆 目录结构、文件名一旦有变化，链接就会变化，其他人访问原链接就是 404 了 而在 hugo 中，可以设置每篇文章的 slug 作为永久链接，这样只需要文章的 slug 全英文，并且保持唯一即可。\n目录结构 相应地， hugo 中其实不存在目录结构的问题，不管在任意文件夹放置 md 文件，随意命名都可以，只要保证 slug 唯一就行了，这样大大方便了文章的组织问题。\n在文章数量少的时期可以按年存放文章，文章数量多起来可以按月、按日，随心所欲。\n自动化部署 这部分直接参考其他教程文章，利用 github action 实现自动化的发布网页到自己的 xxx/xxx.github.io 仓库里，我抄的是 Hugo + GitHub Action，搭建你的博客自动发布系统 里的配置。\n后记 这一圈折腾下来，感觉不坚持写一段时间都对不起自己的折腾之心，哈哈，且行且看。\n","date":"2023-02-09T18:25:40+08:00","image":"https://i-square.github.io/p/Blog-migration-from-hexo-to-hugo/hexo2hugo_hub0df817a0eb7fcf1fcebe5f31ac793aa_185176_120x120_fill_box_smart1_3.png","permalink":"https://i-square.github.io/p/Blog-migration-from-hexo-to-hugo/","title":"博客迁移-从hexo到hugo"},{"content":"问题 升级到 MacOS Monterey 以后会强行恢复 sudoers 文件到默认状态，即使用户在 admin 组里也无法使用 sudo\n当然，此时也是无法修改 sudoers 文件的\n过程 在谷歌搜索了一下，果然已经有人遇到了类似问题，在解决过程中参考了外网的3篇帖子\n尝试 首先找到了这篇帖子： r/MacOS，虽然没有解决问题，但从中学到了从Finder里直接拷贝系统文件的方法，需要权限时会弹框确认（指纹or密码）\nSHIFT + CMD + . 显示隐藏文件 拷贝 /etc/sudoers 文件到可编辑目录 修改文件，加入我的用户（比如user）和免密设置，如下 1 2 3 4 5 ## # User specification root ALL=(ALL:ALL) ALL user ALL=(ALL:ALL) NOPASSWD:ALL ## 再从 Finder 里直接拷贝修改后的问题替换原文件 此时执行 sudo 命令仍然会报错 sudo: /etc/sudoers is owned by uid xxx, should be 0 解决uid问题 之后又在 StackExchange 里学到了两种方式解决这个问题：\n开机按 CMD + S 进入 recovery 模式，以root权限执行如下命令后，即可解决 1 2 3 4 mount -uw / chown root:wheel /etc/sudoers chmod 440 /etc/sudoers reboot 利用 Apple Script 修改文件权限，弹框确认权限（指纹or密码） 1 osascript -e \u0026#39;do shell script \u0026#34;chown root:wheel /etc/sudoers; chmod 440 /etc/sudoers; chmod -N /etc/sudoers\u0026#34; with administrator privileges\u0026#39; 后记 事实上，完全可以直接用Apple Script修改 /etc/sudoers 文件，比如 这篇文章 里提到的方式\n创建一个 /tmp/sudoers 文件，按需修改，然后直接替换 /etc/sudoers 文件即可，如下\n1 osascript -e \u0026#39;do shell script \u0026#34;cat /tmp/sudoers \u0026gt; /etc/sudoers; chown root:wheel /etc/sudoers\u0026#34; with administrator privileges\u0026#39; ","date":"2022-10-17T20:43:45+08:00","image":"https://i-square.github.io/p/Problem-and-solution-of-sudo-unavailability-after-upgrading-to-MacOS12.xMonterey/macOS-Monterey-on-MBP-Feature_hu1008640e18dd0acc8ed4e7705964df34_18386_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://i-square.github.io/p/Problem-and-solution-of-sudo-unavailability-after-upgrading-to-MacOS12.xMonterey/","title":"升级MacOS12.x(Monterey)后sudo失效问题及解决方式"},{"content":"引言 分享内容 工具推荐 方法分享 开拓思路 如何高效？ 聚焦：摒除杂质 有序：有条不紊 简化：化繁为简 浏览器 发展史 内核 Trident（IE） -\u0026gt; EdgeHTML（早期edge） KHTML -\u0026gt; WebKit （早期Safari） ↘ Chromium（早期chrome）-\u0026gt; Blink（后期chrome等） ↘ WebKit2（后期Safari） Gecko（早期firefox） -\u0026gt; Servo Presto（早期opera） 浏览器大战 第一次大战：垄断之战 Netscape Navigator Internet Explorer 第二次大战：标准之战 IE Opera Firefox Safari Chrome Maxthon Edge \u0026hellip; 扩展 广告过滤 Adblock Plus/AdBlock uBlock Origin 脚本管理 Greasemonkey Violentmonkey Tampermonkey 网络代理 AutoProxy SwitchyOmega 键盘导航 Vimium Surfingkeys 实用工具 全局广告过滤 路由器(OpenWrt) Adbyby KoolProxy 桌面端 hosts AdGuard 全局代理管理 系统代理 Proxifier 全局手势 鼠标手势 Win：WGestures/StrokesPlus Ubuntu：EasyStroke 触摸板手势 Win：GestureSign Mac：Jitouch 多任务管理 单机：多桌面+单桌面任务聚焦 多机 原则：扬长避短 VSCode Remote、虚拟机、远程桌面 终端 模拟器 Win：XShell/SecureCRT Mac：iTerm2 会话管理 脚本管理 分屏（显示共用，多终端） zsh 配置：oh my zsh 主题：powerlevel10k tmux 终端复用 Tmux Plugin Manager 会话恢复：tmux-resurrect 会话保存：tmux-continuum docker 环境隔离 轻量化 微服务 k8s shell脚本 grep awk sed ","date":"2022-08-25T17:55:27+08:00","image":"https://i-square.github.io/p/Guide-to-Efficient-Surfing/wave-riding.svg","permalink":"https://i-square.github.io/p/Guide-to-Efficient-Surfing/","title":"高效冲浪指北"},{"content":"背景 为了安全，多数公司会采用跳板机的方式访问内网服务器，登录需要输入AD密码和谷歌验证码，非常繁琐，这里提供一个基于expect脚本的方法，实现一键登录跳板机\n注：笔者在 MacOS 和 Ubuntu20.04 环境下测试ok，其他环境大同小异，按需修改即可。\n方法 此方式思路是利用expect脚本交互式输入预设的AD密码，输入实时获取的谷歌验证码（使用 python authenticator 工具）\n所需依赖 安装以下工具，各平台安装方法请自行搜索：\nexpect python pip authenticator authenticator配置 安装 pip install authenticator 若不成功，请先升级pip到最新版本\n配置 执行 authenticator add $user（AD账号无邮箱后缀） 提示 Enter passphrase 这里输入2次AD密码 提示 Enter shared secret 需要把谷歌验证码的字符串输入到这里 到这里就配置ok了，执行 authenticator generate ，输入AD密码，看到谷歌验证码正常输出就是成功了 配置完成之后就可以使用expect脚本来自动登录了\n注意点 多数公司的AD密码可能需要每隔一段时间更新一次，在更新AD密码后，使用 authenticator 仍然需要输入旧密码，所以下述脚本内相应的做了一下兼容\nexpect脚本 脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/usr/bin/expect set timeout 1000 set USERNAME xxx set PASSWORD_GEN xxxx # 首次配置 authenticator 时使用的密码 set PASSWORD xxxxxxxx # AD密码，每隔 xx 天更新一次 set JUMP_ZONE zone # 假如跳板机区分区域 set LINK_TYPE ssh set DOMAIN example.com # 登录域名 # 判断是否是 vscode 云端环境 if {$JUMP_ZONE != \u0026#34;vscode\u0026#34;} { set main_response \u0026#34;Opt\u0026gt;\u0026#34; } else { set main_response \u0026#34;Ip:\u0026#34; } spawn authenticator generate expect \u0026#34;passphrase:\u0026#34; send \u0026#34;$PASSWORD_GEN\\r\u0026#34; expect \u0026#34;seconds\u0026#34; set found [regexp {([0-9]{6})} $expect_out(buffer) match verify_code] if {$found == 1} { send \\x03 # 发送 Ctrl-C 结束 authenticator 进程 } else { puts \u0026#34;invalid verification code\u0026#34; exit } spawn ${LINK_TYPE} ${USERNAME}@jump-${JUMP_ZONE}.${DOMAIN} expect { \u0026#34;yes/no\u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;Verification code:\u0026#34; { send \u0026#34;$verify_code\\r\u0026#34;; exp_continue } \u0026#34;assword:\u0026#34; { send \u0026#34;$PASSWORD\\r\u0026#34;; exp_continue } \u0026#34;MFA auth\u0026#34; { send \u0026#34;$verify_code\\r\u0026#34;; exp_continue } $main_response { } } interact 使用 把脚本开头的几个变量设置一下，或者自己修改为从argv里读取 USERNAME AD账户不带邮箱后缀 PASSWORD AD密码 JUMP_ZONE 是跳板机的区域代码，按需 LINK_TYPE 是连接协议，比如 ssh | sftp，按需 假设保存文件为 ~/jump_ssh.exp 执行脚本即可自动化登录到跳板机 expect ~/jump_ssh.exp 也可以给脚本加上可执行权限 chmod a+x ~/jump_ssh.exp 然后直接执行即可 ~/jump_ssh.exp ","date":"2022-03-18T17:34:07+08:00","image":"https://i-square.github.io/p/login-to-the-springboard-machine-easily-by-expect-script/login.svg","permalink":"https://i-square.github.io/p/login-to-the-springboard-machine-easily-by-expect-script/","title":"使用expect脚本一键登录跳板机"},{"content":"前言 从前两周开始我的实验室电脑出现了CPU占用率一直保持在25%以上的现象，经过排查发现问题出在OneDriveSetup.exe这个进程上，然而当时我上谷歌各种搜索也没有找到解决办法，后来也就没管，但是今天无意中正好看到解决办法，在这里分享出来，希望遇到这个问题的能够尽早解决。\n解决 解决办法最早是在德国微软论坛里发布的，发布时间是2017年6月26日，这里是原帖地址\n以下是操作步骤：\n在任务管理器里面结束进程OneDriveSetup.exe 进入C:\\Users\\your username\\AppData\\Local\\Microsoft\\OneDrive\\setup\\logs文件夹，删除以下2个文件(如果看不到这两个文件，需要先设置显示隐藏文件和显示系统文件) UserTelemetryCache.otc UserTelemetryCache.otc.session 删除后进入C:\\Users\\your username\\AppData\\Local\\Microsoft\\OneDrive\\Update文件夹运行里面的OneDriveSetup.exe安装更新即可 这个时候OneDriveSetup.exe不会在占用大量CPU，也不会一直在后台跑了，enjoy\n","date":"2017-07-03T22:27:29Z","permalink":"https://i-square.github.io/p/Solution-to-the-problem-that-OneDriveSetup.exe-eat-CPU/","title":"OneDriveSetup.exe占用大量CPU的解决办法"},{"content":"前言 最近在做一个MFC项目，使用了有名的BCG界面库，我的编程平台是 Win10 + VS2015 , 在我自己的机器上测试的时候一直都是使用动态链接的方式，没有什么问题，但是当切换到 Windows Server 2008 R2 系统下，会出现缺少 xxx.dll 的错误，按照往常的做法，缺少的文件也就是VC的运行库，然而我安装VS2015的运行库却失败了，网上一查才发现VS2015的运行时库不支持 Windows Server 2008 R2 ，最低得是 Windows Server 2008 R2 with SP1 ，安装运行库的法子走不通，只能换一条路了。\n静态链接 MFC程序可以用动态链接或者静态链接的方式使用MFC的库，动态链接的好处是最后生成的exe文件非常小，缺点是目标机器必须安装对应的运行库，或者要在文件夹里手动放入所需的dll；静态链接的好处是直接把VC的运行库链接到最终的exe里，不必安装运行库或者添加一堆dll就可以直接运行，缺点是生成的exe会比较大。\n静态链接多占用的那一点空间对我来说没什么影响，所以我打算采取静态链接的方法解决上面提到的问题，MFC的库好办，只需要改项目属性就可以了，而静态链接BCG库则多一点波折，关于如何静态链接BCG库网上也有很多方法，但是并不全面，经过一番查找，我自己总结了在MFC里静态链接BCG库的方法，内容主要参考自BCG技术问答里的这个问题\n总结 准备 编译所需版本的静态库lib文件（这一步在安装BCG库的时候一般做过了，直接拷贝出来就行，如 BCGCBPRO2510STATICU140.lib ） 修改项目属性 C/C++ -\u0026gt; 代码生成 -\u0026gt; 运行库 里选择 MT (release)或者 MTd (debug) 常规 里选择 在静态库中使用 MFC 将BCGSoft\\BCGControlBarPro\\BCGCBPro\\Styles下的 Office 2010 (blue) 文件夹(以该主题为例) BCGPStyle2010Blue.rc 和 BCGPStyle2010Blue.rc2 文件 拷贝到你的项目主目录 修改 stdafx.cpp 在 stdafx.cpp 文件的最后（在 #include stdafx.h 之后）添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 #if _MSC_VER \u0026gt; 1500 #define COMPILE_MULTIMON_STUBS #pragma warning(push) #pragma warning(disable: 4996) #include \u0026#34;multimon.h\u0026#34; #pragma warning(pop) #endif 修改资源文件属性 在资源视图的对话框上点击右键，选择 资源包括(L)...\n在 只读符号指令 里添加 #include \u0026quot;bcgprores.h\u0026quot; 在编译时指令里 移除_AFX_NO_SPLITTER_RESOURCES 添加#include \u0026quot;BCGCBPro.rc\u0026quot;和#include \u0026quot;BCGPStyle2010Blue.rc\u0026quot; 如果你想动态链接MFC，静态链接BCG, 则添加\u0026quot;#define _BCGCBPRO_STATIC_\u0026quot; (这条基本不用管)如果你的项目是从MFC版本2008或更高版本移植的，请删除资源文件中对 afxribbon.rc 的所有引用，因为它和 BCGCBPro.rc 冲突 ","date":"2017-06-19T22:24:59Z","permalink":"https://i-square.github.io/p/Summary-of-MFC-BCG-library-static-link-method/","title":"MFC+BCG库静态链接方法总结"},{"content":"前言 计时器可能是大多数程序员都自己实现过的一个功能，尤其是C++这种没有计时器类可以直接调用的，一般都会自己实现一个，而由于硬件的原因，想要一个跨平台的计时器功能还要兼顾不同的硬件平台，增加程序员的工作量。C++11标准发布之后，新增了chrono命名空间，里面包含了大量与时间相关的功能，利用它可以非常方便的写出一个计时器类。\n旧式计时器类 先说一下以往的方法，在 Windows 平台上，想要实现一个高精度的计时器，一般会用到2个 Windows API ， QueryPerformanceFrequency 和 QueryPerformanceCounter ，配合使用获取高精度时间间隔。而 linux 平台则一般使用 gettimeofday 函数，可以获取微妙精度的时间，如需更高精度，则可能要用到汇编。\n接口 它可能长这样，为了兼顾不同平台，需要预处理宏的帮忙。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;time.h\u0026gt; #ifdef _WIN32 #include \u0026lt;windows.h\u0026gt; #if !defined(_WINSOCK2API_) \u0026amp;\u0026amp; !defined(_WINSOCKAPI_) struct timeval { long tv_sec; long tv_usec; }; #endif #else//_WIN32 #include \u0026lt;sys/time.h\u0026gt; #endif//_WIN32 typedef double timer_dt; class Timer { public: Timer(); ~Timer() {}; void start(); void stop(); timer_dt get_time(); #ifdef _WIN32 double freq; LARGE_INTEGER start_time; LARGE_INTEGER finish_time; #else//_WIN32 struct timeval start_time; struct timeval finish_time; #endif//_WIN32 }; 实现 核心的3个函数start()、stop()和get_time()的实现可能是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 构造函数里获取高精度时钟的频率 Timer::Timer() { #ifdef _WIN32 LARGE_INTEGER tmp; QueryPerformanceFrequency((LARGE_INTEGER*)\u0026amp;tmp); freq = (double)tmp.QuadPart/1000.0; #endif } void Timer::start() { #ifdef _WIN32 QueryPerformanceCounter((LARGE_INTEGER*) \u0026amp;start_time); #else//_WIN32 gettimeofday(\u0026amp;start_time, 0); #endif//_WIN32 } void Timer::stop() { #ifdef _WIN32 QueryPerformanceCounter((LARGE_INTEGER*) \u0026amp;finish_time); #else//_WIN32 gettimeofday(\u0026amp;finish_time, 0); #endif//_WIN32 } timer_dt Timer::get_time() { timer_dt interval = 0.0f; #ifdef _WIN32 interval = (timer_dt)((double)(finish_time.QuadPart - start_time.QuadPart)\t/ freq); #else // time difference in milli-seconds interval = (timer_dt) (1000.0 * ( finish_time.tv_sec - start_time.tv_sec) +(0.001 * (finish_time.tv_usec - start_time.tv_usec))); #endif//_WIN32 return interval; } C++11 计时器类 chrono C++11 标准发布之后，给我们带来了 chrono 命名空间，里面的东西虽说名字特别难记:P，但是用起来很方便，用它来实现一个跨平台、高精度的计时器类只需要十几行代码，甚至核心代码只有3行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;chrono\u0026gt; // 这里为了方便说明直接用了该命名空间，实际情况请酌情使用 using namespace std::chrono; class Timer { public: Timer() : tpStart(high_resolution_clock::now()), tpStop(tpStart) {} public: void start() { tpStart = high_resolution_clock::now(); } void stop() { tpStop = high_resolution_clock::now(); } template \u0026lt;typename span\u0026gt; auto delta() const { return duration_cast\u0026lt;span\u0026gt;(high_resolution_clock::now() - tpStart).count(); } private: time_point\u0026lt;high_resolution_clock\u0026gt; tpStart; time_point\u0026lt;high_resolution_clock\u0026gt; tpStop; }; 没错，只需要这些代码就可以实现一个跨平台且高精度的计时器类，使用方法也非常简单，可以按需选择精度，例：\n1 2 3 4 5 6 7 Timer t; // some code here t.stop(); // 调用 delta() 函数时需指定精度，以下四种均在chrono命名空间内定义 // seconds, milliseconds, microseconds, nanoseconds std::cout \u0026lt;\u0026lt; \u0026#34;the xxx time is: \u0026#34; \u0026lt;\u0026lt; t.delta\u0026lt;nanoseconds\u0026gt;() \u0026lt;\u0026lt; std::endl; // 输出纳秒 std::cout \u0026lt;\u0026lt; \u0026#34;the xxx time is: \u0026#34; \u0026lt;\u0026lt; t.delta\u0026lt;milliseconds\u0026gt;() \u0026lt;\u0026lt; std::endl; // 输出毫秒 为了方便使用，还可以加入以下两个函数。\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;typename span\u0026gt; auto stop_delta() { stop(); return duration_cast\u0026lt;span\u0026gt;(tpStop - tpStart).count(); } template \u0026lt;typename span\u0026gt; auto stop_delta_start() { stop(); auto ts = duration_cast\u0026lt;span\u0026gt;(tpStop - tpStart).count(); start(); return ts; } ratio C++11还增加了 ratio 命名空间，顾名思义，这个命名空间里定义了一堆比率，如 std::milli 、 std::micro 、 std::nano ，配合这些比率我们就可以实现一个返回浮点数的计时器了，核心代码如下，只是修改了一点点内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;chrono\u0026gt; #include \u0026lt;ratio\u0026gt; // 这里为了方便说明直接用了该命名空间，实际情况请酌情使用 using namespace std::chrono; class Timer { public: using s = std::ratio\u0026lt;1, 1\u0026gt;; using ms = std::ratio\u0026lt;1, 1000\u0026gt;; using us = std::ratio\u0026lt;1, 1000000\u0026gt;; using ns = std::ratio\u0026lt;1, 1000000000\u0026gt;; public: Timer() : tpStart(high_resolution_clock::now()), tpStop(tpStart) {} public: void start() { tpStart = high_resolution_clock::now(); } void stop() { tpStop = high_resolution_clock::now(); } template \u0026lt;typename span\u0026gt; auto delta() const { return duration\u0026lt;double, span\u0026gt;(high_resolution_clock::now() - tpStart).count(); } template \u0026lt;typename span\u0026gt; auto stop_delta() { stop(); return duration\u0026lt;double, span\u0026gt;(tpStop - tpStart).count(); } template \u0026lt;typename span\u0026gt; auto stop_delta_start() { stop(); auto ts = duration\u0026lt;double, span\u0026gt;(tpStop - tpStart).count(); start(); return ts; } private: time_point\u0026lt;high_resolution_clock\u0026gt; tpStart; time_point\u0026lt;high_resolution_clock\u0026gt; tpStop; }; 总结 C++11新增的这个 chrono 命名空间非常方便好用，由于是标准库，在跨平台方面具有天然优势，在代码简洁程度上也比原来要好，配合模板更加可以减少代码量，当然它不止能用来做计时器用，还有很多别的方面的应用，在此就不多说了，以后可能会补充。\n","date":"2017-05-22T20:59:21Z","permalink":"https://i-square.github.io/p/Implement-a-simple-timer-class-using-C-11/","title":"使用C++11实现一个简易计时器类"},{"content":"这一章介绍解决等价问题的一种有效数据结构。实现简单，也非常快，每种操作只需要常数平均时间。\n等价关系 (equivalence relation) 若对于每一对元素(a,b),a,b∈S, a R b或者为true或者为false，则称在集合S上定义关系R。如果a R b为true，我们说a和b有关系。\n等价关系是满足下列三个性质的关系R：\n自反性：对于所有的a∈S，a R a 对称性：a R b当且仅当b R a 传递性：若a R b且b R c则a R c 元素a∈S的等价类(equivalence class)是S的子集，它包含所有与a有（等价）关系的元素。注意，等价类形成对S的一个划分：S的每一个成员恰好出现在一个等价类中。为确定是否a~b，我们只需验证a和b是否都在同一个等价类中。\n输入数据最初是N个集合(collection)的类，每个集合含有一个元素。初始的描述是所有的关系均为false（自反的关系除外）。每个集合都有一个不同的元素，从而Si∩Sj=⊙，称为不相交(disjoint)\n基本操作有两种，称为求并/查找(union/find)算法。\n灵巧求并算法 直观的union操作相当随意，它简单地通过使第二棵树成为第一棵树的子树而完成合并。对其进行简单改进，使得总是较小的树成为较大的树的子树，称为按大小求并(union by size)，它保证树的深度最大是O(logN)。\n连续M次操作平均需要O(M)时间。\n另一种方法是按高度求并(union by height)，它同样保证树的深度最大是O(logN)。做法是使浅的树成为深的树的子树。\n一个应用 应用求并/查找数据结构的一个例子是迷宫的生成。初始化时所有格子都在自己的等价类中，之后不断合并，最终生成迷宫。\n","date":"2017-04-24T15:42:58Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-8-Disjoint-set-classes/","title":"数据结构学习笔记（八）：不相交集类"},{"content":"在内存里的排序称为内部排序，而在磁盘上的排序称为外部排序。\n假设输入数据支持\u0026quot;\u0026lt;\u0026ldquo;和\u0026rdquo;\u0026gt;\u0026ldquo;操作符，除赋值运算外，这种运算是仅有的允许对输入数据进行的操作，在此条件下的排序称为基于比较的排序。\n内容 对内部排序的考查将指出：\n存在几种直观的算法以O(N^2)排序，如冒泡、选择、插入排序 希尔排序编程简单，以o(N^2)运行，在实践中很有效 还有一些稍微复杂的O(NlogN)算法 任何只使用比较的排序算法在最坏情形下和平均情形下均需要Ω(NlogN)次比较 插入排序 (insertion sort) 插入排序由N-1趟（pass）排序组成，排序策略是，在第p趟，将位置p上的元素向左移动至它在前p+1个元素中的正确位置上。\n分析 O(N^2) 精确界，反序输入可达。\n若已排序输入，则O(N)\n平均情形Θ(N^2)\n一些简单排序算法的下界 定理1 N个互异元素的数组的平均逆序数是N(N-1)/4\n定理2 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间\n对冒泡排序、选择排序、插入排序都有效\n定理2告诉我们，为了以o(N^2)排序，必须执行比较，特别是要对相距较远的元素进行交换。排序通过删除逆序得以继续进行，为了有效进行，必须每次交换删除多个逆序。\n希尔排序 (shell sort) 发明者是Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。\n它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。因此，希尔排序又是也叫做缩减增量排序(diminishing increment sort)\n分析 使用希尔增量的最坏情形Θ(N^2)\nHibbard增量：1，3，7，…… ，2^k - 1\n使用Hibbard增量的最坏情形Θ(N^(3/2))\nSedgewick提出了几种增量序列，最坏情形时间O(N^(4/3))\n希尔排序的性能在实践中是可以接受的，由于编程简单，适度数量的输入数据经常选用。\n堆排序 (heap sort) 如第六章所说，优先队列可以用O(NlogN)时间进行排序，基于该思想的算法称为堆排序\n由数组建立N个元素的二叉堆花费O(N)时间，每次deleteMin花费O(logN)，N次总共花费O(NlogN)\n使用了附加数组，存储需求增加了一倍\n避免使用附加数组的方法：每次deleteMin之后把min放到刚刚空出来的位置上，N次deleteMin之后，数组将是递减顺序，因此可以构建max堆\n以O(N)建立max堆 交换最后一个和第一个元素，堆大小减1并下滤，相当于执行deleteMax 循环执行步骤2，N-1次 分析 在最坏情形下堆排序最多使用2NlogN-O(N)次比较\n堆排序非常稳定：它平均使用的比较只比最坏情形界指出的略少\n定理1 对N个互异项的随机排列进行堆排序，所用的比较平均次数为2NlogN-O(NloglogN)\n可以证明，堆排序总是至少使用NlogN-O(N)次比较，而且存在达到这个界的数据。似乎平均情形也应该是2NlogN-O(N)次比较（而不是定理1中的第二项），但目前无法证明\n归并排序 (merge sort) 以最坏情形O(NlogN)时间运行，所使用的比较次数几乎是最优的，它是递归算法的一个很好的实例\n算法的基本操作是合并两个已排序的表，取两个输入A、B，一个输出C，每次将A、B中的小者放入C，相关的位置推进，这显然是线性的\n算法 基准情形：N=1时，结果是显然的\n否则，递归地将前半部分和后半部分各自归并排序，再将两部分合并\n该算法是经典的分治策略，它将问题分(divide)成一些小问题然后递归求解，而治(conquering)的阶段则是将分的阶段解得的各答案合并在一起\n分析 分析递归例程技巧的经典实例：必须给运行时间写出一个递推关系。\n假设N是2的幂，从而总可以将它分裂成相等的两部分。对于N=1，所用时间是常数，将其记为1。则有\nT(1) = 1\nT(N) = 2T(N/2) + N\n求解得 T(N) = NlogN + N = O(NlogN)\n利弊：在java中比较耗时多于移动，因此在java中归并排序是一般目的排序的最佳选择；但在C++中，比较耗时少而复制对象代价很大，因此实践中不常用\n快速排序 (quick sort) 快排是实践中最快的已知排序算法，平均运行时间是O(NlogN)，最坏情形是O(N^2)，但稍作努力就可避免。\n通过将堆排序与快速排序结合，可以在堆排序O(NlogN)最坏运行时间下，得到几乎所有输入的最快运行时间。\n快排也是分治的递归算法，排序数组S步骤如下：\n若S中元素数是0或1，则返回 取S中任一元素v，称之为枢纽元(pivot) 将S-{v}（S中其余元素）划分成两个不相交的集合：S1={x∈S-{v}|x≤v}和S2={x∈S-{v}|x≥v} 返回{quickSort(S1),后跟v,继而quickSort(S2)} 第三步中划分的标准不是唯一的，因此这就成了设计决策。一部分好的实现方法是将这种情形尽可能有效地处理。直观地看，我们希望枢纽元能将元素对半分，一半在S1，另一半在S2。\n选取枢纽元 一种典型的错误是将第一个元素选作枢纽元。若输入随机，那么这是可以接受的，但实际情况有很多预排序的序列，这样的分割是劣质的。类似的还有选取前2个元素的大者，这是一样的，不要使用。 一种安全的做法是随机选取枢纽元，但这取决于随机数生成器的质量，而且声称随机数的代价一般也是很昂贵的。 三数中值分割法\n一组N个数的中值是第上取整(N/2)个最大的数。枢纽元的最好选择是数组的中值，但算出中值代价太高。一般的做法是选取左端、右端和中心位置上的三个元素的中值作为枢纽元。显然该方法消除了预排序输入的不好情形，并且减少了约14%的比较次数。 分割策略 将枢纽元与最后的元素交换 i从第一个元素开始，j从倒数第二个元素开始 当i在j左边时，右移i，移过小于枢纽元的元素，j左移，移过大于枢纽元的元素，i,j都停止时交换两个元素，直到i,j交错 将枢纽元与i所指向的元素交换 如何处理等于枢纽元的元素？\n若等于，则停止移动\n小数组 对于很小的数组（N≤20），快速排序不如插入排序，而且，因为快排是递归的，这样的情形经常发生。通常的解决办法是，对于小数组使用插入排序。一种好的截止范围(cutoff range)是N=10\n分析 最坏情形：O(N^2) 最佳情形：O(NlogN) 平均情形：O(NlogN)\n快速选择 (quick select) 修改快速排序以解决选择问题，即找第k个最大（小）元。\n前3步和快速排序一样\n第4步\n若k≤S1，那么k必然在S1中，返回quickSelect(S1, K) 若k = 1 + |S1|，那么枢纽元就是第k个最小元 否则，第k个最小元就在S2中，它是S2中的第（k-|S1|-1）个最小元，返回quickSelect(S2, k-|S1|-1) 分析 与快排相比，快速选择只进行了一次递归调用而不是两次\n最坏情形：O(N^2)，当S1和S2一个是空时 平均情形：O(N)\n","date":"2017-04-23T22:01:12Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-7-sorting/","title":"数据结构学习笔记（七）：排序"},{"content":"本章讨论优先队列（priority queue），介绍优先队列在离散事件模拟中的应用\n作者评价：这类数据结构属于计算机科学中最雅致的一种\n内容 优先队列ADT的高效实现 优先队列的使用 优先队列的高级实现 二叉堆 (binary heap) 插入删除最坏O(logN)，实际上插入花费常数平均时间，若无删除干扰，该结构将以线性时间建立一个具有N项的优先队列。\n与二叉查找树一样，堆具有两个性质，堆的操作必须满足所有性质才能终止。\n结构性质 堆是一棵完全二叉树（三角形缺右下角），特例是满二叉树（三角形），最底层元素必须从左往右填入，如有空缺则不是完全二叉树\n一棵高为h的完全二叉树有[2^h , 2^(h+1) - 1]个节点，这意味着完全二叉树的高是 下取整(logN)，显然它是O(logN)的\n因为此规律，所以堆可以用数组表示而不用链表，对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的(2i+1)上，它的父亲在位置 下取整(i/2) 上\n堆序性质 在堆中，除根节点以外，每一个节点的值都大于（或等于）它的父节点的值\n根据堆序性质，最小值总在根结点，因此可以以O(1)时间做findMin\n相应地，通过改变堆序性质，也可以建立一个max堆，以O(1)时间做findMax\n插入（上滤策略） 为了插入新元素X，在堆的下一个可用位置（为了满足结构性质）创建一个空穴，若X放入空穴仍满足堆序性质，则插入完成，否则交换空穴和其父节点，直到X被放入并满足堆序性质为止\n删除（下滤策略） 找出最小元很容易，难的是删除它。\n当删除一个最小元时，堆中最后一个元素X必须移动到该堆的某个地方。策略是在根节点建立一个空穴，然后将两个儿子中的较小者移入空穴，重复该步骤直到X可以被放入空穴中。代码中则是用X直接替换根结点的值，然后下滤。\n注意 在堆的实现中经常出现的错误是，当堆中存在偶数个元素时，将出现一个节点只有一个儿子的情况。因此我们必须以节点不总有两个儿子为前提，这需要额外的测试。\n应用 选择问题 输入N个元素及整数k，找出第k个最大的元素，极端情况是k=上取整(N/2)，此时实际上是找中位数，以下两个算法都能在找中位数的情况下以O(NlogN)时间运行\nA 将N个元素读入数组，对数组应用buildHeap，再执行k次deleteMin，最后根节点上的就是第k个最小值，构造一个最大堆就可以找到第k个最大值 B 用buildHeap将前k个元素构造成一个最大堆，若下一个元素大于堆里的最小值，则删除最小值，插入新元素，最终的最小值就是所求的第k个最大值 d堆 类似B树，深度变浅，每个节点有d个儿子\n左式堆 (leftist heap) 左式堆也是二叉树，但它不是理想平衡的，事实上是趋于非常不平衡\n定义任一节点X的**零路径长(null path length)**npl(X)为从X到一个不具有两个儿子的节点的最短路径长\n因此，具有0个或1个儿子的节点npl为0，而npl(NULL)=-1\n注意，任一节点的npl比它儿子节点的npl的最小值多1\n左式堆性质 对于堆中的每一个节点X，左儿子的npl至少与右儿子的npl一样大\n这个性质导致树向左增加深度，沿左式堆右侧的右路径是堆中最短的路径\n定理：在右路径上有r个节点的左式堆必然至少有2^r -1个节点\n对左式堆的基本操作是合并。插入可以看成是合并一个单节点堆，删除即是删掉根结点，然后合并左右子树。\n斜堆 (skew heap) 斜堆是左式堆的自调节形式，具有堆序，但不存在结构限制。斜堆不需要存储npl，每次合并无条件交换左右儿子。\n二项队列 (binomial queue) 以最坏O(logN)支持插入、合并、deleteMin，插入操作平均花费常数时间\n实质是由二项树(binomial tree)构成的森林(forest)。\n每一个高度上最多存在一棵二项树。高度为k的二项树Bk是通过将一棵二项树B(k-1)附接到另一棵二项树B(k-1)的根上构成的。高度为k的二项树有2^k个节点，在深度d处的节点数是二项系数C(d,k)\n如果把堆序性质施加到二项树上并允许任意高度上最多一棵二项树，则可以用二项树的集合唯一地表示任意大小的优先队列。如大小为13的优先队列可以用B3,B2,B0表示，可以写成1101，同时也是13的二进制形式。\n操作 基本操作仍然是合并，思想是从小到大合并相同高度的二项树\n插入是特殊情况下的合并\ndeleteMin将原二项队列一分为二，再合并\n编程需要注意进位的实现\n","date":"2017-04-20T22:27:15Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-6-priority-queue-heap/","title":"数据结构学习笔记（六）：优先队列（堆）"},{"content":"前言 实验室里有一台高配工作站，内存有512GB，用一块256GB的SSD安装Win7 x64操作系统以后，硬盘空间只剩下几十MB了，查看C盘下的文件之后，发现有两个隐藏的系统文件占用了200GB+的空间，于是马上查了它们的来头。\npagefile.sys pagefile.sys 是系统安装过程中创建的虚拟内存页面文件。这个文件的大小是自己系统虚拟内存设置的最小值的大小。假如虚拟内存的设置为800MB－1600MB 那么你在自己的设定驱动盘下面就可看到大小为800MB的 pagefile.sys 文件。\n优化方法 通常自己可以在 我的电脑 右键 属性 \u0026ndash;\u0026gt; 高级 \u0026ndash;\u0026gt; 性能 \u0026ndash;\u0026gt; 高级 \u0026ndash;\u0026gt; 虚拟内存 中将所有盘的虚拟内存设置为无分页文件，并选择设置后重启系统，就可以删除页面文件pagefile.sys。\nhiberfil.sys 这个文件是系统的休眠功能所占用的硬盘空间的文件（Windows默认休眠功能是处于打开状态的），电脑处于休眠状态时，内存中的所有内容将保存到硬盘，并且电脑会被关闭。电脑在返回打开状态之后，关闭电脑时打开的所有程序和文档将全都还原到桌面。也就是说，当你让电脑进入休眠状态时，Windows在关闭系统前将所有的内存内容写入 hiberfil.sys 文件，当你重新打开电脑，操作系统使用 hiberfil.sys 把所有信息放回内存，电脑恢复到关闭前的状态。然而，只要休眠功能开启，Windows就会在硬盘上留下 hiberfil.sys 文件，即使你从来不休眠。\n优化方法 以管理员身份运行CMD，然后输入命令 powercfg -h off ，回车后立即生效， hiberfil.sys 文件已经不见了。\n","date":"2017-04-19T16:24:22Z","permalink":"https://i-square.github.io/p/Description-of-the-two-sys-files-in-the-root-directory-of-the-C-drive/","title":"C盘根目录下的两个sys文件说明"},{"content":"散列表（hash table）的实现通常称为散列（hashing），指用于以O(1)时间执行插入、删除和查找的技术，但不支持需要排序信息的树操作，比如findMin、findMax以及在线性时间内按顺序打印整个表都不支持\n内容 中心数据结构是散列表\n实现散列表的几种方法 分析比较几种方法 介绍散列的多种应用 比较散列表与二叉查找树 散列函数 基本思想：将每个键(Key)映射到从[0, TableSize)这个范围中的某个数，并且将其放到适当的单元中，这个映射就称为散列函数。\n问题：选择一个函数，决定当两个键散列到同一个值的时候（称为**冲突(collision)**应该做什么以及如何确定散列表的大小。\n注：一般使表的大小为素数，有助于避免部分冲突问题\n装填因子(load factor) 定义散列表的装填因子 λ 为散列表中的元素个数与散列表大小的比值。\n分离链接法 将散列到同一个值的所有元素保留到一个链表中。\n一般法则：使 λ ≈ 1，控制链表的长度，若 λ \u0026gt; 1 则通过再散列扩充\n开放定址法 不用链表存储，实现分配较大空间，称为探测散列表\nhi(x) = (hash(x) + f(i)) mod TableSize, f(0) = 0.\n一般 λ \u0026gt; 0.5 就要再散列\n线性探测 f(i) = i 平方探测 f(i) = i^2 双散列 f(i) = i * hash2(x), hash2(x) = R - (x mod R) 这样的函数会起作用，其中R为小于TableSize的素数 再散列(rehash) 只要表到一半就再散列 只有插入失败时才再散列 途中策略：当表到达某一个装填因子时进行再散列（最优） ","date":"2017-04-07T22:48:51Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-5-hash/","title":"数据结构学习笔记（五）：散列"},{"content":"内容 了解树是如何用于实现文件系统的 了解树如何用来计算算术表达式的值 了解如何用树实现O(logN)时间进行搜素 讨论并使用set和map 二叉树的遍历 前序：先处理自己后处理左右儿子 中序：先处理左儿子再处理自己再处理右儿子 后序：先处理左右儿子再处理自己 二叉查找树（平均深度O(logN)） 性质：对于树中的每个节点X，左子树中所有项的值小于X中的项，右子树中所有项的值大于X中的项\n缺点：不能动态调整，若输入为已排序序列则构造出最坏情况下的斜树\nAVL树 带有平衡条件的二叉查找树 一棵AVL树是每个节点的左子树和右子树的高度最多相差1的二叉查找树（空树高度定义为-1） 插入新节点可能破坏AVL树的平衡，需要通过旋转解决 把需要平衡的节点叫α\n对α的左儿子的左子树进行一次插入 对α的左儿子的右子树进行一次插入 对α的右儿子的左子树进行一次插入 对α的右儿子的右子树进行一次插入 1和4（左左，右右）发生在外边，进行一次单旋转即可，2和3（左右，右左）则发生在内部，需要通过双旋转调整\n伸展树 节点可以达到任意深度，每次访问某节点后把该节点调整为根节点，任意连续M次操作花费O(MlogN)时间\nB树（平衡M路树） M=3时：2-3树，实现平衡查找树的另一种方法\n注意 通过插入元素构造查找树，然后执行中序遍历，可以得到排序后的元素。\n这是一种O(NlogN)的排序算法\n","date":"2017-03-31T22:05:29Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-4-tree/","title":"数据结构学习笔记（四）：树"},{"content":"问题 安装MathType6.9b后打开Word2016，发现菜单栏里并没有集成MathType，想办法解决以后，菜单栏上已经集成了MathType，但是仍然不能用，每次打开Word都会弹框提示Mathpage.wll未找到，无奈又去网上找寻了解决办法，在这里记录一下，就当云笔记了。\n解决办法 Office2016支持 Office2016需要在MathType根目录下添加文件MPlugin.dll，一般在安装文件夹里\nMathpage.wll未找到问题 通过以下方法解决(以Office2016为例)：\n依次打开 Word→文件→选项→信任中心→信任中心设置→受信任位置→添加新位置\n添加 C:\\Program Files\\Microsoft Office\\Office16\\STARTUP，然后关闭Word 在mathtype安装目录下找到以下2个文件(以64位系统为例): C:\\Program Files (x86)\\MathType\\MathPage\\64\\MathPage.wll C:\\Program Files (x86)\\MathType\\Office Support\\64\\MathType Commands 6 For Word 2016.dotm 将两个文件分别拷贝到对应的文件夹中: 将 MathType Commands 6 For Word 2016.dotm 拷贝到 C:\\Program Files\\Microsoft Office\\Office16\\STARTUP 将 MathPage.wll 拷贝到 C:\\Program Files\\Microsoft Office\\Office16 重新打开Word你会发现一切都OK了! ","date":"2017-03-29T18:37:43Z","permalink":"https://i-square.github.io/p/Solution-to-the-problem-that-MathType6.9b-is-not-compatible-with-Office2016/","title":"MathType6.9b不兼容Office2016的解决办法"},{"content":"内容 介绍三种基本的数据结构 介绍抽象数据类型(ADT, abstract data type)的概念 介绍栈ADT及其在实现递归方面的应用 介绍队列ADT及其在操作系统和算法设计中的应用 给出vector和list的重要子集的实现 栈 实现 栈是一个表，因此任何实现表的方法都能实现栈。\n应用 符号平衡 后缀（逆波兰）表达式计算 中缀到后缀的转换 函数调用\n（代码实现了一个简单的计算器，应保证输入合法） 总结 快慢指针 ex 3.34 提示：判断一个链表是否有环，只使用O(1)的额外空间，使用两个迭代器p,q p每次递增1，q每次递增2，若q到了末尾则没环，否则pq必定在环中间相遇\n也可用于快速找出单链表的中间节点\n","date":"2017-03-27T15:27:43Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-3-tables-stacks-and-queues/","title":"数据结构学习笔记（三）：表、栈和队列"},{"content":"问题 在Office2016中，右键Visio图像，只有“转换”功能，而不再提供之前早期Office中提供的“打开”和“编辑”功能，那么，如何能够在Office2016中打开visio图像呢？\n解决办法 在Visio图上使用 ALT + 双击鼠标左键 即可在Visio中打开\n直接双击Visio图像则是和之前版本一样，在当前Office窗口中打开Visio图。\n","date":"2017-03-26T15:21:56Z","permalink":"https://i-square.github.io/p/Solution-to-the-problem-that-cannot-open-the-Visio-object-by-right-click-in-Office2016/","title":"Office2016中右键无法打开Visio图像的解决办法"},{"content":"内容 主要内容是复杂度分析 大O标记 计算大O时的一般法则 对数规律的一般法则\n如果一个算法用常数时间（O(1)）将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。 例子 二分搜索提供了O(logN)的查找算法 最大公因数的欧几里得算法也是O(logN)的 幂运算的递归算法 ","date":"2017-03-25T22:48:53Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-2-algorithm-analysis/","title":"数据结构学习笔记（二）：算法分析"},{"content":"内容 介绍基本数学知识 简要复习递归 介绍用到的C++知识 递归的四条基本法则 基准情形。必须总有某些基准情形不用递归就能求解。 不断推进。对于那些需要递归求解的情形，递归调用必须总能够朝着基准情形的方向推进。 设计法则。假设所有的递归调用都能运行。 合成效益法则。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。 ","date":"2017-03-24T14:22:23Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-1-introduction/","title":"数据结构学习笔记（一）：引论"},{"content":"前言 为了准备今年后半年到来的秋招，我决定开始学习数据结构，为后面的学习打基础，采用的教材是weiss的《数据结构与算法分析C++描述》，计划实现书上上的示例代码以及力所能及的课后习题。\n在Github上同步源码，项目地址：https://github.com/i-square/Data-Structure\n学习环境 Windows 10 \u0026amp; 8.1 Visual Studio 2015 with update 3 C++ (部分C++11语法) ","date":"2017-03-23T11:23:54Z","permalink":"https://i-square.github.io/p/Data-structure-study-notes-0-start/","title":"数据结构学习笔记（零）：开始"},{"content":"前言 因为之前提到的Gihub学生包，我入手了 DigitalOcean 的VPS，由于刚刚接触VPS，对于VPS的安全性并没有什么概念，所以我直接使用一个汉化版PuTTY客户端，以root账户在22端口登录的，刚开始登录几次都没出现什么状况，然而隔天登录的时候就出现了类似以下的提示，这才让我产生了要提高VPS安全性的想法。\nLast failed login: Tue Feb 10 23:32:08 EST 2017 from static-15-64-34.rpnspl.com on ssh:notty There were 166 failed login attempts since the last successful login. Last login: Tue Feb 10 18:54:37 2017 from ip\n这里的 ip 并不是我的IP地址，也就是说有人(或机器人)在恶意试探我的VPS密码。看到这提示，我马上上谷歌搜索，发现这个现象非常普遍，多数都是被机器人扫描然后试图暴力破解，如果不加以防范，代价会很大。\n我在查问题的时候发现，PuTTY官方并没有提供中文版本，所以网上的汉化版有可能被植入后门，非常不安全，所以在此提醒，这一类涉及重要密码的软件绝对不要用民间汉化版！\n那么如何知道自己的VPS账号正在遭受扫描和暴力破解呢？简单的方法就是查看日志：\n1 2 3 4 5 6 7 8 9 10 # 查看登录成功的用户信息 last # 最新的登录记录在最前面，所以可以用以下命令来查看。 last | less # 查看登录失败的用户信息 lastb # 查看登录日志 tail /var/log/secure 也可以执行以下命令，查询出来的结果中包含了ip地址=数量就是攻击者信息。\n1 cat /var/log/secure|awk \u0026#39;/Failed/{print $(NF-3)}\u0026#39;|sort|uniq -c|awk \u0026#39;{print $2\u0026#34;=\u0026#34;$1;}\u0026#39; 如何来增强VPS账号的安全性呢？除了养成使用正规软件的好习惯外，还要从VPS本身来加强VPS账号的安全性。\nLinux有一个自动统计VPS登录错误的工具： Denyhosts ，一旦登录VPS账号错误次数超过了 Denyhosts 的安全设置， Denyhosts 就会将该IP记录下来，同时将其放入黑名单当中，禁止该IP在某一段时间内继续访问VPS，通过它可以实现自动封锁恶意IP 默认的SSH端口是22，通过修改自己的SSH端口先为扫描者增加一道端口门槛 VPS默认的账号是root，如果我们禁用了root，那么要攻破账号又得先暴力猜测VPS的账号，难度又增加几分 如果还不放心，我们可以直接禁用密码登录验证VPS的方式，改用密钥登录，这样安全系数是相当高了 注：本人主机为CentOS 7 x64系统，以下内容均基于此环境\nDenyhosts攻击 Linux各平台现在基本上都可以直接安装Denyhosts了，直接运行命令安装 1 yum install denyhosts 安装好了Denyhosts，默认的配置基本上就可以防御一定的暴力攻击了， /etc/hosts.deny 文件里保存了被屏蔽的记录。\n如果你要自定义Denyhosts的相关配置，执行： vi /etc/denyhosts.conf ，相关参数的说明可以自行搜索，一般用户默认即可。\n修改SSH端口 输入命令\n1 vi /etc/ssh/sshd_config 编辑SSH服务的配置文件，找到 #port 22 ，将前面的 # 去掉，然后将 22 修改为你自己设定的端口号，如 12345 ，保存后重启SSH服务以使配置生效\n1 systemctl restart sshd.service 禁用Root账户 禁用root账户之前，必须先新建一个新的账户。\n1 2 useradd user #添加用户名 passwd user #为user用户设置密码 然后编辑配置文件\n1 vi /etc/ssh/sshd_config 找到里面的 PermitRootLogin yes ，将后面的 yes 改成 no ，如果没有这一行则直接加入即可。保存后重启SSH服务以使配置生效\n1 systemctl restart sshd.service 使用密钥登录 生成密钥 SSH登录方式有账号+密码和密钥认证两种形式，为了阻止暴力破解VPS的账号和密码，我们可以放弃密码验证的方式，改用密钥文件验证。\n以普通用户(如user)执行以下命令，在VPS上生成密钥文件\n1 ssh-keygen -t rsa 生成密钥时会询问你密钥保存的位置，默认是 /username/.ssh ，保持默认即可，你还可以为你的密钥设置一个密码，默认为空。\n密钥生成后，进入密钥存放的目录中，执行以下命令，将公钥生成一个新的文件。\n1 cat id_rsa.pub \u0026gt;\u0026gt; authorized_keys 将id-rsa这个私钥文件用winSCP下载到本地，打开PuTTYGen软件，执行Conversions-\u0026gt;Import Key，导入这个私钥文件，然后选择Save private key，这时会在本地生成一个PPK文件，在PuTTY的 Connection/SSH/Auth 中选择刚刚保存的PPK文件，以后即可用密钥认证登录VPS了。\nCentOS 7权限问题 CentOS 7系统下，用户user的home目录： /home/user 的权限变成了 777 ，造成不能正常登陆SSH，报如下错误： Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password)\nSSH对公钥、私钥的权限和所有权的要求是非常严格的，总结如下： 1、下面两个目录的所有权必须是 user ，所属组也应该是 user ，权限必须为 700\n/home/user /home/user/.ssh\n2、下面公钥文件的所有权必须是 user ，所属组也应该是 user ，权限必须为 644\n/home/user/.ssh/authorized_keys\n3、下面私钥文件的所有权必须是 user ，所属组也应该是 user ，权限必须是 600\n/home/user/.ssh/id_rsa\n接着上面的操作，这次需要获取root权限，首先输入命令 su 再输入root密码获取root权限，然后依次执行以下命令\n1 2 3 4 5 mkdir /etc/ssh/user cp /home/user/.ssh/authorized_keys /etc/ssh/user/ chmod 755 /etc/ssh/user chmod 600 /etc/ssh/user/authorized_keys chown -R user:user /etc/ssh/user 编辑SSH配置文件\n1 vi /etc/ssh/sshd_config 找到 AuthorizedKeysFile 这项(如果没有则添加)，修改为\n1 AuthorizedKeysFile /etc/ssh/%u/authorized_keys 保存后重启SSH服务以使配置生效\n1 systemctl restart sshd.service 禁止密码登录 注意：请确认你已经可以通过密钥认证的方式登录VPS\n有了密钥登录VPS，我们就可以禁止用密码登录这种验证方式了，还是 编辑SSH配置文件\n1 vi /etc/ssh/sshd_config 找到 PasswordAuthentication (没有则添加)并修改后面的 yes 为 no ，保存后重启SSH服务以使配置生效\n1 systemctl restart sshd.service 小结 通过以上这些措施可以有效防范暴力破解VPS，平时使用官方软件也是提升安全性的一大举措，总而言之，没有绝对的安全，但是只要我们平时稍加留心就不会给破解者可乘之机。\n","date":"2017-03-06T09:24:30Z","permalink":"https://i-square.github.io/p/Common-Ways-to-Enhance-VPS-Security/","title":"增强VPS安全性的常用方法"},{"content":"前言 从2013年我搭建的第一个 Wordpress 博客开始，我陆陆续续尝试过各种博客类网站，有自己搭建的 Wordpress 博客，也有诸如 点点网 和 lofter 这样的轻博客社区，但最终都是留下一篇 hello world 走人。\n缘起 近两年随着 github 的火热，搭建在 github pages 上的博客也如雨后春笋一般噌噌地冒出来，我也想尝尝鲜，于是在大谷歌搜索到一篇文章：使用GitHub和Hexo搭建免费静态Blog，作者：wsgzao，然后照猫画虎搭建了自己的博客，非常感谢原文博主分享自己的经验，让我这个门外汉也能轻松上手。\n展望 这次使用 Hexo + github 的博客我希望能够长时间更新下去，博客定位大方向是我自己的学习笔记、思考感悟，也会写一些生活随笔，说不定也会分享一些图片、音乐、视频等等，:)\n多说点儿 刚开始学习用 Markdown 写文章，还不是太习惯，用到的语法也只有一两种，慢慢完善吧，:P\n","date":"2017-02-25T17:27:39Z","permalink":"https://i-square.github.io/p/New-Start-Hexo/","title":"新的起点"},{"content":"测试 首先发布一篇测试文章，以后慢慢扩充。\n龟速学习 Markdown 语法ing。\n","date":"2017-02-24T14:33:36Z","permalink":"https://i-square.github.io/p/Post-Test/","title":"Post Test 发布测试"},{"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post 1 $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server 1 $ hexo server More info: Server\nGenerate static files 1 $ hexo generate More info: Generating\nDeploy to remote sites 1 $ hexo deploy More info: Deployment\n","date":"2017-02-23T15:15:45Z","permalink":"https://i-square.github.io/p/Hexo-Hello-World/","title":"Hello World"}]